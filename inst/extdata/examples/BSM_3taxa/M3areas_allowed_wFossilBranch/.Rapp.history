numstates=NULL
dmat_times = get_dmat_times_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=BioGeoBEARS_run_object, BioGeoBEARS_model_object=BioGeoBEARS_model_object, numstates=numstates)
get_dmat_times_from_res(res, numstates=16)
get_Qmat_COOmat_from_BioGeoBEARS_run_object()
inputs$max_range_size
res$inputs$max_range_size
get_dmat_times_from_res <- function(res, numstates=NULL, max_range_size=NULL)#
	{#
	setup='#
	# Set up a fake results object#
	res = NULL#
	res$inputs = define_BioGeoBEARS_run()#
	res$outputs = res$inputs$BioGeoBEARS_model_object#
	res#
	# Get the dmat (trivial case, non-stratified Psychotria example)#
	get_dmat_times_from_res(res, numstates=NULL, max_range_size=4)#
	'#
	if (isblank_TF(res$inputs$max_range_size) == FALSE)#
		{#
		max_range_size = res$inputs$max_range_size#
		} else {#
		if (isblank_TF(max_range_size) == FALSE)#
			{#
			res$inputs$max_range_size = max_range_size#
			}#
		}#
	# You need either numstates or max_range_size for downstream functions#
	if (is.null(max_range_size))#
		{#
		txt = "STOP ERROR in get_dmat_times_from_res(): either max_range_size or res$inputs$max_range_size must be specified."#
		cat("\n\n")#
		cat(txt)#
		stop(txt)#
		cat("\n\n")#
		}#
	########################################################
	# Load the model object#
	########################################################
	BioGeoBEARS_run_object = res$inputs#
	BioGeoBEARS_model_object = res$output#
	include_null_range = BioGeoBEARS_run_object$include_null_range#
	# Get the matrices based on the OUTPUT model parameters#
	dmat_times = get_dmat_times_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=BioGeoBEARS_run_object, BioGeoBEARS_model_object=BioGeoBEARS_model_object, numstates=numstates)#
	return(dmat_times)#
	}
res = NULL#
	res$inputs = define_BioGeoBEARS_run()#
	res$outputs = res$inputs$BioGeoBEARS_model_object#
	res#
	# Get the dmat (trivial case, non-stratified Psychotria example)#
	get_dmat_times_from_res(res, numstates=NULL, max_range_size=4)
res$inputs$max_range_size = 4#
	get_dmat_times_from_res(res, numstates=NULL, max_range_size=NULL)
get_dmat_times_from_BioGeoBEARS_run_object <- function(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, max_range_size=NULL)#
	{#
	setup='#
	# Set up a BioGeoBEARS_run_object#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
	\dontrun{#
	# Produces stop error#
	get_dmat_times_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, max_range_size=NULL)#
	}#
	# Works:#
	# Get the dmat (trivial case, non-stratified Psychotria example)#
	get_dmat_times_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object, numstates=NULL, max_range_size=4)#
	# Also works:#
	res$inputs$max_range_size = 4#
	get_dmat_times_from_res(res, numstates=NULL, max_range_size=NULL)#
	'#
	# Error check#
	if (isblank_TF(rBioGeoBEARS_run_object$max_range_size) == FALSE)#
		{#
		max_range_size = BioGeoBEARS_run_object$max_range_size#
		} else {#
		if (isblank_TF(max_range_size) == FALSE)#
			{#
			BioGeoBEARS_run_object$max_range_size = max_range_size#
			}#
		}#
	# You need either numstates or max_range_size for downstream functions#
	if (is.null(max_range_size))#
		{#
		txt = "STOP ERROR in get_dmat_times_from_res(): either max_range_size or BioGeoBEARS_run_object$max_range_size must be specified."#
		cat("\n\n")#
		cat(txt)#
		stop(txt)#
		cat("\n\n")#
		}#
	# Setup#
	include_null_range = BioGeoBEARS_run_object$include_null_range#
	if (is.null(BioGeoBEARS_model_object))#
		{#
		BioGeoBEARS_model_object = BioGeoBEARS_run_object$BioGeoBEARS_model_object#
		} # END if (is.null(BioGeoBEARS_model_object))#
	# Get the times, if present#
	times = NULL#
	if (is.null(BioGeoBEARS_run_object$timeperiods) == TRUE)#
		{#
		if (is.na(BioGeoBEARS_run_object$timesfn) == FALSE)#
			{#
			times = read_times_fn(BioGeoBEARS_run_object)#
			} # END if (is.na(BioGeoBEARS_run_object$timesfn) == FALSE)#
		} else {#
		times = BioGeoBEARS_run_object$timeperiods#
		} # END if (is.null(BioGeoBEARS_run_object$timeperiods) == TRUE)#
	# If there are times, iterate through them to get the dmat list#
	if (is.null(BioGeoBEARS_run_object$timeperiods) == TRUE)#
		{#
		returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=BioGeoBEARS_run_object, BioGeoBEARS_model_object=BioGeoBEARS_model_object, numstates=numstates, include_null_range=include_null_range, timeperiod_i=1)#
		dmat = returned_mats$dmat#
		} else {#
		dmat_list = NULL#
		for (i in 1:length(times))#
			{#
			returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=BioGeoBEARS_run_object, BioGeoBEARS_model_object=BioGeoBEARS_model_object, numstates=numstates, include_null_range=include_null_range, timeperiod_i=i)#
			dmat_list[[i]] = returned_mats$dmat#
			} # END for (i in 1:length(times))#
		dmat = dmat_list#
		} # END if (is.null(BioGeoBEARS_run_object$timeperiods) == TRUE)#
	dmat_times = NULL#
	dmat_times$dmat = dmat#
	dmat_times$times = times#
	extract='#
	dmat = dmat_times$dmat#
	times = dmat_times$times#
	'#
	return(dmat_times)#
	} # END get_dmat_times_from_BioGeoBEARS_run_object <- function(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, include_null_range=TRUE)
get_dmat_times_from_res <- function(res, numstates=NULL, max_range_size=NULL)#
	{#
	setup='#
	# Set up a fake results object#
	res = NULL#
	res$inputs = define_BioGeoBEARS_run()#
	res$outputs = res$inputs$BioGeoBEARS_model_object#
	res#
	\dontrun{#
	# Produces stop error#
	get_dmat_times_from_res(res, numstates=NULL, max_range_size=NULL)#
	}#
	# Works:#
	# Get the dmat (trivial case, non-stratified Psychotria example)#
	get_dmat_times_from_res(res, numstates=NULL, max_range_size=4)#
	# Also works:#
	res$inputs$max_range_size = 4#
	get_dmat_times_from_res(res, numstates=NULL, max_range_size=NULL)#
	'#
	# Error check#
	if (isblank_TF(res$inputs$max_range_size) == FALSE)#
		{#
		max_range_size = res$inputs$max_range_size#
		} else {#
		if (isblank_TF(max_range_size) == FALSE)#
			{#
			res$inputs$max_range_size = max_range_size#
			}#
		}#
	# You need either numstates or max_range_size for downstream functions#
	if (is.null(max_range_size))#
		{#
		txt = "STOP ERROR in get_dmat_times_from_res(): either max_range_size or res$inputs$max_range_size must be specified."#
		cat("\n\n")#
		cat(txt)#
		stop(txt)#
		cat("\n\n")#
		}#
	########################################################
	# Load the model object#
	########################################################
	BioGeoBEARS_run_object = res$inputs#
	BioGeoBEARS_model_object = res$output#
	include_null_range = BioGeoBEARS_run_object$include_null_range#
	# Get the matrices based on the OUTPUT model parameters#
	dmat_times = get_dmat_times_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=BioGeoBEARS_run_object, BioGeoBEARS_model_object=BioGeoBEARS_model_object, numstates=numstates)#
	return(dmat_times)#
	}
get_dmat_times_from_BioGeoBEARS_run_object <- function(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, max_range_size=NULL)#
	{#
	setup='#
	# Set up a BioGeoBEARS_run_object#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
	# Produces stop error#
	get_dmat_times_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, max_range_size=NULL)#
	# Works:#
	# Get the dmat (trivial case, non-stratified Psychotria example)#
	get_dmat_times_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object, numstates=NULL, max_range_size=4)#
	# Also works:#
	res$inputs$max_range_size = 4#
	get_dmat_times_from_res(res, numstates=NULL, max_range_size=NULL)#
	'#
	# Error check#
	if (isblank_TF(rBioGeoBEARS_run_object$max_range_size) == FALSE)#
		{#
		max_range_size = BioGeoBEARS_run_object$max_range_size#
		} else {#
		if (isblank_TF(max_range_size) == FALSE)#
			{#
			BioGeoBEARS_run_object$max_range_size = max_range_size#
			}#
		}#
	# You need either numstates or max_range_size for downstream functions#
	if (is.null(max_range_size))#
		{#
		txt = "STOP ERROR in get_dmat_times_from_res(): either max_range_size or BioGeoBEARS_run_object$max_range_size must be specified."#
		cat("\n\n")#
		cat(txt)#
		stop(txt)#
		cat("\n\n")#
		}#
	# Setup#
	include_null_range = BioGeoBEARS_run_object$include_null_range#
	if (is.null(BioGeoBEARS_model_object))#
		{#
		BioGeoBEARS_model_object = BioGeoBEARS_run_object$BioGeoBEARS_model_object#
		} # END if (is.null(BioGeoBEARS_model_object))#
	# Get the times, if present#
	times = NULL#
	if (is.null(BioGeoBEARS_run_object$timeperiods) == TRUE)#
		{#
		if (is.na(BioGeoBEARS_run_object$timesfn) == FALSE)#
			{#
			times = read_times_fn(BioGeoBEARS_run_object)#
			} # END if (is.na(BioGeoBEARS_run_object$timesfn) == FALSE)#
		} else {#
		times = BioGeoBEARS_run_object$timeperiods#
		} # END if (is.null(BioGeoBEARS_run_object$timeperiods) == TRUE)#
	# If there are times, iterate through them to get the dmat list#
	if (is.null(BioGeoBEARS_run_object$timeperiods) == TRUE)#
		{#
		returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=BioGeoBEARS_run_object, BioGeoBEARS_model_object=BioGeoBEARS_model_object, numstates=numstates, include_null_range=include_null_range, timeperiod_i=1)#
		dmat = returned_mats$dmat#
		} else {#
		dmat_list = NULL#
		for (i in 1:length(times))#
			{#
			returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=BioGeoBEARS_run_object, BioGeoBEARS_model_object=BioGeoBEARS_model_object, numstates=numstates, include_null_range=include_null_range, timeperiod_i=i)#
			dmat_list[[i]] = returned_mats$dmat#
			} # END for (i in 1:length(times))#
		dmat = dmat_list#
		} # END if (is.null(BioGeoBEARS_run_object$timeperiods) == TRUE)#
	dmat_times = NULL#
	dmat_times$dmat = dmat#
	dmat_times$times = times#
	extract='#
	dmat = dmat_times$dmat#
	times = dmat_times$times#
	'#
	return(dmat_times)#
	} # END get_dmat_times_from_BioGeoBEARS_run_object <- function(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, include_null_range=TRUE)
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
	# Produces stop error#
	get_dmat_times_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, max_range_size=NULL)
get_dmat_times_from_BioGeoBEARS_run_object <- function(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, max_range_size=NULL)#
	{#
	setup='#
	# Set up a BioGeoBEARS_run_object#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
	# Produces stop error#
	get_dmat_times_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, max_range_size=NULL)#
	# Works:#
	# Get the dmat (trivial case, non-stratified Psychotria example)#
	get_dmat_times_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object, numstates=NULL, max_range_size=4)#
	# Also works:#
	res$inputs$max_range_size = 4#
	get_dmat_times_from_res(res, numstates=NULL, max_range_size=NULL)#
	'#
	# Error check#
	if (isblank_TF(BioGeoBEARS_run_object$max_range_size) == FALSE)#
		{#
		max_range_size = BioGeoBEARS_run_object$max_range_size#
		} else {#
		if (isblank_TF(max_range_size) == FALSE)#
			{#
			BioGeoBEARS_run_object$max_range_size = max_range_size#
			}#
		}#
	# You need either numstates or max_range_size for downstream functions#
	if (is.null(max_range_size))#
		{#
		txt = "STOP ERROR in get_dmat_times_from_res(): either max_range_size or BioGeoBEARS_run_object$max_range_size must be specified."#
		cat("\n\n")#
		cat(txt)#
		stop(txt)#
		cat("\n\n")#
		}#
	# Setup#
	include_null_range = BioGeoBEARS_run_object$include_null_range#
	if (is.null(BioGeoBEARS_model_object))#
		{#
		BioGeoBEARS_model_object = BioGeoBEARS_run_object$BioGeoBEARS_model_object#
		} # END if (is.null(BioGeoBEARS_model_object))#
	# Get the times, if present#
	times = NULL#
	if (is.null(BioGeoBEARS_run_object$timeperiods) == TRUE)#
		{#
		if (is.na(BioGeoBEARS_run_object$timesfn) == FALSE)#
			{#
			times = read_times_fn(BioGeoBEARS_run_object)#
			} # END if (is.na(BioGeoBEARS_run_object$timesfn) == FALSE)#
		} else {#
		times = BioGeoBEARS_run_object$timeperiods#
		} # END if (is.null(BioGeoBEARS_run_object$timeperiods) == TRUE)#
	# If there are times, iterate through them to get the dmat list#
	if (is.null(BioGeoBEARS_run_object$timeperiods) == TRUE)#
		{#
		returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=BioGeoBEARS_run_object, BioGeoBEARS_model_object=BioGeoBEARS_model_object, numstates=numstates, include_null_range=include_null_range, timeperiod_i=1)#
		dmat = returned_mats$dmat#
		} else {#
		dmat_list = NULL#
		for (i in 1:length(times))#
			{#
			returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=BioGeoBEARS_run_object, BioGeoBEARS_model_object=BioGeoBEARS_model_object, numstates=numstates, include_null_range=include_null_range, timeperiod_i=i)#
			dmat_list[[i]] = returned_mats$dmat#
			} # END for (i in 1:length(times))#
		dmat = dmat_list#
		} # END if (is.null(BioGeoBEARS_run_object$timeperiods) == TRUE)#
	dmat_times = NULL#
	dmat_times$dmat = dmat#
	dmat_times$times = times#
	extract='#
	dmat = dmat_times$dmat#
	times = dmat_times$times#
	'#
	return(dmat_times)#
	} # END get_dmat_times_from_BioGeoBEARS_run_object <- function(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, include_null_range=TRUE)#
# Get the Q matrix and cladogenesis mode from the#
# BioGeoBEARS_results_object "res"#
get_Qmat_COOmat_from_res <- function(res, numstates=NULL, include_null_range=TRUE, timeperiod_i=1)#
	{#
	########################################################
	# Load the model object#
	########################################################
	BioGeoBEARS_run_object = res$inputs#
	BioGeoBEARS_model_object = res$output#
	# Get the matrices based on the OUTPUT model parameters#
	returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=BioGeoBEARS_run_object, BioGeoBEARS_model_object=BioGeoBEARS_model_object, numstates=numstates, include_null_range=include_null_range, timeperiod_i=timeperiod_i)#
	return(returned_mats)#
	}
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
	# Produces stop error#
	get_dmat_times_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, max_range_size=NULL)
get_dmat_times_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object, numstates=NULL, max_range_size=4)
get_Qmat_COOmat_from_res <- function(res, numstates=NULL, include_null_range=TRUE, max_range_size=NULL, timeperiod_i=1)#
	{#
	setup='#
	# Set up a fake results object#
	res = NULL#
	res$inputs = define_BioGeoBEARS_run()#
	res$outputs = res$inputs$BioGeoBEARS_model_object#
	res#
	# Produces stop error#
	get_Qmat_COOmat_from_res(res, numstates=NULL, include_null_range=TRUE, max_range_size=NULL)#
	# Works:#
	# Get the dmat (trivial case, non-stratified Psychotria example)#
	get_dmat_times_from_res(res, numstates=NULL, max_range_size=4)#
	# Also works:#
	res$inputs$max_range_size = 4#
	get_dmat_times_from_res(res, numstates=NULL, max_range_size=NULL)#
	'#
	########################################################
	# Load the model object#
	########################################################
	BioGeoBEARS_run_object = res$inputs#
	BioGeoBEARS_model_object = res$output#
	# Get the matrices based on the OUTPUT model parameters#
	returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=BioGeoBEARS_run_object, BioGeoBEARS_model_object=BioGeoBEARS_model_object, numstates=numstates, include_null_range=include_null_range, timeperiod_i=timeperiod_i)#
	return(returned_mats)#
	}
res = NULL#
	res$inputs = define_BioGeoBEARS_run()#
	res$outputs = res$inputs$BioGeoBEARS_model_object#
	res#
	# Produces stop error#
	get_Qmat_COOmat_from_res(res, numstates=NULL, include_null_range=TRUE, max_range_size=NULL)
# Works:#
	# Get the dmat (trivial case, non-stratified Psychotria example)#
	get_Qmat_COOmat_from_res(res, numstates=NULL, max_range_size=4)#
	# Also works:#
	res$inputs$max_range_size = 4#
	get_Qmat_COOmat_from_res(res, numstates=NULL, max_range_size=NULL)
res$inputs$max_range_size = 4#
	items = get_Qmat_COOmat_from_res(res, numstates=NULL, max_range_size=NULL)#
	items#
	names(items)
get_Qmat_COOmat_from_BioGeoBEARS_run_object <- function(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, max_num_areas=NULL, include_null_range=TRUE, timeperiod_i=1)#
	{#
	setup='#
	# Set up a fake results object#
	res = NULL#
	res$inputs = define_BioGeoBEARS_run()#
	res$outputs = res$inputs$BioGeoBEARS_model_object#
	res#
	# Produces stop error#
	get_Qmat_COOmat_from_BioGeoBEARS_run_object(res, numstates=NULL, include_null_range=TRUE, max_range_size=NULL)#
	# Works:#
	# Get the dmat (trivial case, non-stratified Psychotria example)#
	returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(res, numstates=NULL, max_range_size=4)#
	returned_mats#
	names(returned_mats)#
	# Also works:#
	res$inputs$max_range_size = 4#
	returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(res, numstates=NULL, max_range_size=NULL)#
	returned_mats#
	names(returned_mats)#
	'#
#
	########################################################
	# Load the model object#
	########################################################
	# These are the inputs for a run#
	inputs = BioGeoBEARS_run_object#
#
	# Error check#
	if (isblank_TF(inputs$max_range_size) == FALSE)#
		{#
		max_range_size = inputs$max_range_size#
		} else {#
		if (isblank_TF(max_range_size) == FALSE)#
			{#
			inputs$max_range_size = max_range_size#
			}#
		}#
	# You need either numstates or max_range_size for downstream functions#
	if (is.null(max_range_size))#
		{#
		txt = "STOP ERROR in get_Qmat_COOmat_from_BioGeoBEARS_run_object(): either max_range_size or BioGeoBEARS_run_object$max_range_size must be specified."#
		cat("\n\n")#
		cat(txt)#
		stop(txt)#
		cat("\n\n")#
		}#
	# IF the user specifies a set of model parameters from the #
	# output, DON'T take the model parameters from the input#
	if (is.null(BioGeoBEARS_model_object) == TRUE)#
		{#
		BioGeoBEARS_model_object = BioGeoBEARS_run_object$BioGeoBEARS_model_object#
		} else {#
		# Use this if e.g. extracting from res (results object, AFTER a run)#
		BioGeoBEARS_model_object=BioGeoBEARS_model_object#
		}#
	# Should the optim run be printed?#
	print_optim = inputs$print_optim#
	# Get geographic ranges at tips#
	if (inputs$use_detection_model == FALSE)#
		{#
		tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=np(inputs$geogfn))#
		}#
	if (inputs$use_detection_model == TRUE)#
		{#
		tipranges = tipranges_from_detects_fn(detects_fn=inputs$detects_fn)#
		} # END if (inputs$use_detection_model == TRUE)#
	# Should we do optimx speedup?#
	speedup = inputs$speedup#
	# Get the list of geographic areas#
	areas = getareas_from_tipranges_object(tipranges)#
	areas_list = seq(0, length(areas)-1, 1)		# 0-base indexes#
#
	# Calculate the number of states, if needed#
	if (is.null(numstates))#
		{#
		numstates = numstates_from_numareas(numareas=length(areas), maxareas=inputs$max_range_size, include_null_range=include_null_range)#
		}#
#
	# Change the names to tipranges@df:#
	# this doesn't make sense if areas_list is 0-based indexes#
	#names(tipranges@df) = areas_list#
#
	########################################################
	# Set the maximum range size (this could be thought of as#
	# a free parameter, sort of)#
	########################################################
	if (is.na(inputs$max_range_size))#
		{#
		if (is.null(inputs$states_list))#
			{#
			# Maximum range size is all areas#
			max_range_size = length(areas)#
			} else {#
			# If not NA#
			# Get max rangesize from states list#
			max_range_size = max(sapply(X=inputs$states_list, FUN=length), na.rm=TRUE)#
			}#
		} else {#
		# Maximum range size hard-coded#
		max_range_size = inputs$max_range_size#
		}#
	max_numareas = max_range_size#
	########################################################
	# Check that no tips have larger ranges than you allowed#
	########################################################
	TF = (rowSums(dfnums_to_numeric(tipranges@df))) > max_range_size#
	if (sum(TF, na.rm=TRUE) > 0)#
		{#
		cat("\n\nERROR: Tips with ranges too big:\n", sep="")#
		print(dfnums_to_numeric(tipranges@df)[TF, ])#
		cat("\n\nCheck your input geography file!\n", sep="")#
		txt = paste("ERROR: Some tips (listed above) have range sizes larger than ", max_range_size, sep="")#
		stop(txt)#
		}#
	# Get the areas and states list from time-stratified list#
	newstrat = TRUE#
	if ((is.null(BioGeoBEARS_run_object$lists_of_states_lists_0based) == FALSE) && (newstrat == TRUE))#
		{#
		area_nums = sort(unique(unlist(inputs$lists_of_states_lists_0based)))#
		area_nums#
		state_indices_0based_all_timeperiods = unique(unlist(inputs$lists_of_states_lists_0based, recursive=FALSE))#
		# Get the numbers as collapsed characters, to be sure sorting into correct order#
		state_indices_0based_all_timeperiods = sort_list_of_lists_of_numbers(state_indices_0based_all_timeperiods)#
		states_list_this_timeperiod = inputs$lists_of_states_lists_0based[[timeperiod_i]]#
		states_allowed_this_timeperiod_TF = state_indices_0based_all_timeperiods %in% states_list_this_timeperiod#
		states_allowed_this_timeperiod_TF#
		states_list = states_list_this_timeperiod#
		} # END if (!is.null(inputs$lists_of_states_lists_0based) == TRUE)#
	# Or get the (fixed) list of states#
	if ((is.null(BioGeoBEARS_run_object$lists_of_states_lists_0based) == TRUE) || (newstrat == FALSE))#
		{#
		# Take the list of areas, and get list of possible states#
		# (the user can manually input states if they like)#
		if (is.null(BioGeoBEARS_run_object$states_list))#
			{#
			states_list = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)#
			states_list#
			#BioGeoBEARS_run_object$states_list = states_list#
			#inputs$states_list = states_list#
			} else {#
			states_list = BioGeoBEARS_run_object$states_list#
			#BioGeoBEARS_run_object$states_list = states_list#
			#inputs$states_list = states_list#
			}#
		} # END if ((is.null(inputs$lists_of_states_lists_0based) == TRUE) || (newstrat == FALSE))#
	if (is.na(BioGeoBEARS_run_object$force_sparse))#
		{#
		if (length(states_list) > 128)#
			{#
			force_sparse = TRUE#
			cat("\nNote: force_sparse being set to TRUE, as length(states_list) > 128\n", sep="")#
			} else {#
			force_sparse = FALSE#
			}#
		} else {#
		force_sparse = BioGeoBEARS_run_object$force_sparse#
		}#
#
	if (force_sparse == TRUE)#
		{#
		cat("\nNote: force_sparse is set to TRUE; length(states_list)=", length(states_list), "\n", sep="")#
		}#
	########################################################
	# Load the phylogenetic tree#
	########################################################
	trfn = np(inputs$trfn)#
	#phy = read.tree(file=trfn)#
	phy = check_trfn(trfn=trfn)#
	########################################################
	# Read the stratification/distances input files, if any#
	########################################################
	inputs = readfiles_BioGeoBEARS_run(inputs=inputs)#
	########################################################
	# FROM CALC_LOGLIKE_SP_FOR_OPTIM()#
	########################################################
	# Set the dispersal and extinction rate#
	d = BioGeoBEARS_model_object@params_table["d","est"]#
	e = BioGeoBEARS_model_object@params_table["e","est"]#
	a = BioGeoBEARS_model_object@params_table["a","est"]#
	########################################################
	########################################################
	# Do branch-length exponentiation if desired#
	########################################################
	########################################################
	b = BioGeoBEARS_model_object@params_table["b","est"]#
	# Modify the edge.lengths#
	phy$edge.length = phy$edge.length ^ b#
	# Make sure this doesn't duplicate a previous "^b", e.g.#
	# the summarization step in bears_optim_run#
#
	########################################################
	########################################################
	# Do distance-dependence and dispersal multipliers matrix#
	########################################################
	########################################################
	# Equal dispersal in all directions (unconstrained)#
	# Equal extinction probability for all areas#
	areas = areas_list#
	# If there is a distance matrix, use the timeperiod_i'th one #
	# By default, this is 1 (non-stratified analysis, here)#
	# otherwise, it could be any timeperiod_i#
	if ( (is.null(BioGeoBEARS_run_object$list_of_distances_mats) == FALSE))#
		{#
		distances_mat = BioGeoBEARS_run_object$list_of_distances_mats[[timeperiod_i]]#
		} else {#
		# Default is all areas effectively equidistant#
		distances_mat = matrix(1, nrow=length(areas), ncol=length(areas))#
		}#
#
	# Get the exponent on distance, apply to distances matrix#
	x = BioGeoBEARS_model_object@params_table["x","est"]#
	dispersal_multipliers_matrix = distances_mat ^ x#
	# Environmental distances#
	if ( (is.null(BioGeoBEARS_run_object$list_of_envdistances_mats) == FALSE))#
		{#
		envdistances_mat = BioGeoBEARS_run_object$list_of_envdistances_mats[[timeperiod_i]]#
		} else {#
		# Default is all areas effectively equidistant#
		envdistances_mat = matrix(1, nrow=length(areas), ncol=length(areas))#
		}#
#
	# Get the exponent on environmental distance, apply to distances matrix#
	n = BioGeoBEARS_model_object@params_table["n","est"]#
	dispersal_multipliers_matrix = dispersal_multipliers_matrix * envdistances_mat ^ n#
	# Apply manual dispersal multipliers, if any#
	# If there is a manual dispersal multipliers matrix, use the first one #
	# (non-stratified analysis, here)#
	if ( (is.null(BioGeoBEARS_run_object$list_of_dispersal_multipliers_mats) == FALSE))#
		{#
		manual_dispersal_multipliers_matrix = BioGeoBEARS_run_object$list_of_dispersal_multipliers_mats[[timeperiod_i]]#
		} else {#
		# Default is all areas effectively equidistant#
		manual_dispersal_multipliers_matrix = matrix(1, nrow=length(areas), ncol=length(areas))#
		}#
	# Get the exponent on manual dispersal multipliers#
	w = BioGeoBEARS_model_object@params_table["w","est"]#
#
	# Apply element-wise#
	dispersal_multipliers_matrix = dispersal_multipliers_matrix * manual_dispersal_multipliers_matrix ^ w#
#
	########################################################
	# multiply parameter d by dispersal_multipliers_matrix#
	########################################################
	dmat_times_d = dispersal_multipliers_matrix * matrix(d, nrow=length(areas), ncol=length(areas))#
	amat = dispersal_multipliers_matrix * matrix(a, nrow=length(areas), ncol=length(areas))#
	########################################################
	########################################################
	# Do area-dependence and extinction multipliers list#
	########################################################
	########################################################
	if ( (is.null(BioGeoBEARS_run_object$list_of_area_of_areas) == FALSE))#
		{#
		area_of_areas = BioGeoBEARS_run_object$list_of_area_of_areas[[timeperiod_i]]#
		} else {#
		# Default is all areas effectively equidistant#
		area_of_areas = rep(1, length(areas))#
		}#
	# Get the exponent on extinction, apply to extinction modifiers	#
	u = BioGeoBEARS_model_object@params_table["u","est"]#
	extinction_modifier_list = area_of_areas ^ (1 * u)#
	# Apply to extinction rate#
	elist = extinction_modifier_list * rep(e, length(areas))#
	# Set up the instantaneous rate matrix (Q matrix)#
	# someday we'll have to put "a" (anagenic range-switching) in here...#
	Qmat = rcpp_states_list_to_DEmat(areas_list=areas_list, states_list=states_list, dmat=dmat_times_d, elist=elist, amat=amat, include_null_range=TRUE, normalize_TF=TRUE, makeCOO_TF=force_sparse)#
#
	########################################################
	# Cladogenic model#
	########################################################
	j = BioGeoBEARS_model_object@params_table["j","est"]#
	ysv = BioGeoBEARS_model_object@params_table["ysv","est"]#
	ys = BioGeoBEARS_model_object@params_table["ys","est"]#
	v = BioGeoBEARS_model_object@params_table["v","est"]#
	y = BioGeoBEARS_model_object@params_table["y","est"]#
	s = BioGeoBEARS_model_object@params_table["s","est"]#
	sum_SPweights = y + s + j + v#
	maxent_constraint_01 = BioGeoBEARS_model_object@params_table["mx01","est"]#
	# Text version of speciation matrix	#
	maxent_constraint_01v = BioGeoBEARS_model_object@params_table["mx01v","est"]#
	#spPmat = symbolic_to_relprob_matrix_sp(spmat, cellsplit="\\+", mergesym="*", ys=ys, j=j, v=v, maxent_constraint_01=maxent_constraint_01, maxent_constraint_01v=maxent_constraint_01v, max_numareas=max_numareas)#
	# Set the parameter controlling the size distribution of #
	# the smaller descendant species#
	maxent01s_param = BioGeoBEARS_model_object@params_table["mx01s","est"]#
	maxent01v_param = BioGeoBEARS_model_object@params_table["mx01v","est"]#
	maxent01j_param = BioGeoBEARS_model_object@params_table["mx01j","est"]#
	maxent01y_param = BioGeoBEARS_model_object@params_table["mx01y","est"]#
	# Cladogenesis model inputs#
	spPmat_inputs = NULL#
#
	# Note that this gets the dispersal multipliers matrix, which is applied to #
	# e.g. the j events, NOT the dmat_times_d above which is d*dispersal_multipliers_matrix#
	dmat = dispersal_multipliers_matrix#
	spPmat_inputs$dmat = dmat#
#
	states_indices = states_list#
#
	# shorten the states_indices by 1 (cutting the #
	# null range state from the speciation matrix)#
	if (include_null_range == TRUE)#
		{#
		states_indices[1] = NULL#
		} # END if (include_null_range == TRUE)#
	spPmat_inputs$l = states_indices#
	spPmat_inputs$s = s#
	spPmat_inputs$v = v#
	spPmat_inputs$j = j#
	spPmat_inputs$y = y#
	spPmat_inputs$maxent01s_param = maxent01s_param#
	spPmat_inputs$maxent01v_param = maxent01v_param#
	spPmat_inputs$maxent01j_param = maxent01j_param#
	spPmat_inputs$maxent01y_param = maxent01y_param#
	########################################################
	# From calc_loglike_sp()#
	########################################################
#
	# defaults#
	calc_ancprobs = TRUE#
	cppSpMethod = 3#
	printmat = FALSE#
	# Fix "l" (which is states_indices, i.e. a list of lists of state_indices)#
	# so that there is no "null geographic range", i.e. no "_", no "-", no "NA"#
	if ( is.null(spPmat_inputs)==FALSE )#
		{#
		spPmat_inputs$l[spPmat_inputs$l == c("_")] = NULL#
		spPmat_inputs$l[spPmat_inputs$l == c("-")] = NULL#
		spPmat_inputs$l[spPmat_inputs$l == c("-1")] = NULL#
		#spPmat_inputs$l[spPmat_inputs$l == c(-1)] = NULL#
		}#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	# Take the max of the indices of the possible areas, and add 1#
	# numareas = max(unlist(spPmat_inputs$l), na.rm=TRUE) + 1 # old, bogus#
	numareas = max(sapply(X=spPmat_inputs$l, FUN=length), na.rm=TRUE) + 0#
	maxent01s_param = spPmat_inputs$maxent01s_param#
	maxent01v_param = spPmat_inputs$maxent01v_param#
	maxent01j_param = spPmat_inputs$maxent01j_param#
	maxent01y_param = spPmat_inputs$maxent01y_param#
	maxent01s = relative_probabilities_of_subsets(max_numareas=numareas, maxent_constraint_01=maxent01s_param, NA_val=0)#
	maxent01v = relative_probabilities_of_vicariants(max_numareas=numareas, maxent_constraint_01v=maxent01v_param, NA_val=0)#
	maxent01j = relative_probabilities_of_subsets(max_numareas=numareas, maxent_constraint_01=maxent01j_param, NA_val=0)#
	maxent01y = relative_probabilities_of_subsets(max_numareas=numareas, maxent_constraint_01=maxent01y_param, NA_val=0)#
#
	# You really need a list of sizes here:#
	# Matrix of probs for each ancsize#
	maxprob_as_function_of_ancsize_and_decsize = mapply(FUN=max, maxent01s, maxent01v, maxent01j, maxent01y, MoreArgs=list(na.rm=TRUE))#
	maxprob_as_function_of_ancsize_and_decsize = matrix(data=maxprob_as_function_of_ancsize_and_decsize, nrow=nrow(maxent01s), ncol=ncol(maxent01s))#
	maxprob_as_function_of_ancsize_and_decsize[maxprob_as_function_of_ancsize_and_decsize > 0] = 1#
	maxprob_as_function_of_ancsize_and_decsize[maxprob_as_function_of_ancsize_and_decsize <= 0] = 0#
	# Now, go through, and make a list of the max minsize for each decsize#
	max_minsize_as_function_of_ancsize = apply(X=maxprob_as_function_of_ancsize_and_decsize, MARGIN=1, FUN=maxsize)#
	tmpca_1 = rep(1, (numstates-1))#
	tmpcb_1 = rep(1, (numstates-1))#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=tmpca_1, Rcpp_rightprobs=tmpcb_1, l=l, s=s, v=v, j=j, y=y, dmat=dispersal_multipliers_matrix, maxent01s=maxent01s, maxent01v=maxent01v, maxent01j=maxent01j, maxent01y=maxent01y, max_minsize_as_function_of_ancsize=max_minsize_as_function_of_ancsize, printmat=printmat)#
	# combine with C++ function#
	# This causes an error with spPmat=NULL; spPmat_inputs=NULL; use_cpp=TRUE; sparse=FALSE#
	# i.e. gives 16 states with a 0 on the end, rather than 15 states#
	#Rsp_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar=COO_weights_columnar, numstates=numstates)#
	# This gives 15 states#
	Rsp_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar=COO_weights_columnar)#
	Qmat#
	rowSums(Qmat)	# yep, they sum to 0#
	max(rowSums(Qmat))#
	COO_weights_columnar#
	Rsp_rowsums#
	returned_mats = NULL#
	returned_mats$states_list = states_list#
	returned_mats$spPmat_inputs = spPmat_inputs#
	returned_mats$areas_list = areas_list#
	returned_mats$dmat = dmat#
	returned_mats$Qmat = Qmat#
	returned_mats$COO_weights_columnar = COO_weights_columnar#
	returned_mats$Rsp_rowsums = Rsp_rowsums#
	return(returned_mats)#
	}
res$inputs = define_BioGeoBEARS_run()#
	res$outputs = res$inputs$BioGeoBEARS_model_object#
	res#
	# Produces stop error#
	get_Qmat_COOmat_from_BioGeoBEARS_run_object(res, numstates=NULL, include_null_range=TRUE, max_range_size=NULL)#
	# Works:#
	# Get the dmat (trivial case, non-stratified Psychotria example)#
	returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(res, numstates=NULL, max_range_size=4)#
	returned_mats#
	names(returned_mats)#
	# Also works:#
	res$inputs$max_range_size = 4#
	returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(res, numstates=NULL, max_range_size=NULL)#
	returned_mats#
	names(returned_mats)
get_Qmat_COOmat_from_BioGeoBEARS_run_object <- function(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, max_range_size=NULL, include_null_range=TRUE, timeperiod_i=1)#
	{#
	setup='#
	# Set up a fake results object#
	res = NULL#
	res$inputs = define_BioGeoBEARS_run()#
	res$outputs = res$inputs$BioGeoBEARS_model_object#
	res#
	# Produces stop error#
	get_Qmat_COOmat_from_BioGeoBEARS_run_object(res, numstates=NULL, include_null_range=TRUE, max_range_size=NULL)#
	# Works:#
	# Get the dmat (trivial case, non-stratified Psychotria example)#
	returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(res, numstates=NULL, max_range_size=4)#
	returned_mats#
	names(returned_mats)#
	# Also works:#
	res$inputs$max_range_size = 4#
	returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(res, numstates=NULL, max_range_size=NULL)#
	returned_mats#
	names(returned_mats)#
	'#
#
	########################################################
	# Load the model object#
	########################################################
	# These are the inputs for a run#
	inputs = BioGeoBEARS_run_object#
#
	# Error check#
	if (isblank_TF(inputs$max_range_size) == FALSE)#
		{#
		max_range_size = inputs$max_range_size#
		} else {#
		if (isblank_TF(max_range_size) == FALSE)#
			{#
			inputs$max_range_size = max_range_size#
			}#
		}#
	# You need either numstates or max_range_size for downstream functions#
	if (is.null(max_range_size))#
		{#
		txt = "STOP ERROR in get_Qmat_COOmat_from_BioGeoBEARS_run_object(): either max_range_size or BioGeoBEARS_run_object$max_range_size must be specified."#
		cat("\n\n")#
		cat(txt)#
		stop(txt)#
		cat("\n\n")#
		}#
	# IF the user specifies a set of model parameters from the #
	# output, DON'T take the model parameters from the input#
	if (is.null(BioGeoBEARS_model_object) == TRUE)#
		{#
		BioGeoBEARS_model_object = BioGeoBEARS_run_object$BioGeoBEARS_model_object#
		} else {#
		# Use this if e.g. extracting from res (results object, AFTER a run)#
		BioGeoBEARS_model_object=BioGeoBEARS_model_object#
		}#
	# Should the optim run be printed?#
	print_optim = inputs$print_optim#
	# Get geographic ranges at tips#
	if (inputs$use_detection_model == FALSE)#
		{#
		tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=np(inputs$geogfn))#
		}#
	if (inputs$use_detection_model == TRUE)#
		{#
		tipranges = tipranges_from_detects_fn(detects_fn=inputs$detects_fn)#
		} # END if (inputs$use_detection_model == TRUE)#
	# Should we do optimx speedup?#
	speedup = inputs$speedup#
	# Get the list of geographic areas#
	areas = getareas_from_tipranges_object(tipranges)#
	areas_list = seq(0, length(areas)-1, 1)		# 0-base indexes#
#
	# Calculate the number of states, if needed#
	if (is.null(numstates))#
		{#
		numstates = numstates_from_numareas(numareas=length(areas), maxareas=inputs$max_range_size, include_null_range=include_null_range)#
		}#
#
	# Change the names to tipranges@df:#
	# this doesn't make sense if areas_list is 0-based indexes#
	#names(tipranges@df) = areas_list#
#
	########################################################
	# Set the maximum range size (this could be thought of as#
	# a free parameter, sort of)#
	########################################################
	if (is.na(inputs$max_range_size))#
		{#
		if (is.null(inputs$states_list))#
			{#
			# Maximum range size is all areas#
			max_range_size = length(areas)#
			} else {#
			# If not NA#
			# Get max rangesize from states list#
			max_range_size = max(sapply(X=inputs$states_list, FUN=length), na.rm=TRUE)#
			}#
		} else {#
		# Maximum range size hard-coded#
		max_range_size = inputs$max_range_size#
		}#
	max_numareas = max_range_size#
	########################################################
	# Check that no tips have larger ranges than you allowed#
	########################################################
	TF = (rowSums(dfnums_to_numeric(tipranges@df))) > max_range_size#
	if (sum(TF, na.rm=TRUE) > 0)#
		{#
		cat("\n\nERROR: Tips with ranges too big:\n", sep="")#
		print(dfnums_to_numeric(tipranges@df)[TF, ])#
		cat("\n\nCheck your input geography file!\n", sep="")#
		txt = paste("ERROR: Some tips (listed above) have range sizes larger than ", max_range_size, sep="")#
		stop(txt)#
		}#
	# Get the areas and states list from time-stratified list#
	newstrat = TRUE#
	if ((is.null(BioGeoBEARS_run_object$lists_of_states_lists_0based) == FALSE) && (newstrat == TRUE))#
		{#
		area_nums = sort(unique(unlist(inputs$lists_of_states_lists_0based)))#
		area_nums#
		state_indices_0based_all_timeperiods = unique(unlist(inputs$lists_of_states_lists_0based, recursive=FALSE))#
		# Get the numbers as collapsed characters, to be sure sorting into correct order#
		state_indices_0based_all_timeperiods = sort_list_of_lists_of_numbers(state_indices_0based_all_timeperiods)#
		states_list_this_timeperiod = inputs$lists_of_states_lists_0based[[timeperiod_i]]#
		states_allowed_this_timeperiod_TF = state_indices_0based_all_timeperiods %in% states_list_this_timeperiod#
		states_allowed_this_timeperiod_TF#
		states_list = states_list_this_timeperiod#
		} # END if (!is.null(inputs$lists_of_states_lists_0based) == TRUE)#
	# Or get the (fixed) list of states#
	if ((is.null(BioGeoBEARS_run_object$lists_of_states_lists_0based) == TRUE) || (newstrat == FALSE))#
		{#
		# Take the list of areas, and get list of possible states#
		# (the user can manually input states if they like)#
		if (is.null(BioGeoBEARS_run_object$states_list))#
			{#
			states_list = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)#
			states_list#
			#BioGeoBEARS_run_object$states_list = states_list#
			#inputs$states_list = states_list#
			} else {#
			states_list = BioGeoBEARS_run_object$states_list#
			#BioGeoBEARS_run_object$states_list = states_list#
			#inputs$states_list = states_list#
			}#
		} # END if ((is.null(inputs$lists_of_states_lists_0based) == TRUE) || (newstrat == FALSE))#
	if (is.na(BioGeoBEARS_run_object$force_sparse))#
		{#
		if (length(states_list) > 128)#
			{#
			force_sparse = TRUE#
			cat("\nNote: force_sparse being set to TRUE, as length(states_list) > 128\n", sep="")#
			} else {#
			force_sparse = FALSE#
			}#
		} else {#
		force_sparse = BioGeoBEARS_run_object$force_sparse#
		}#
#
	if (force_sparse == TRUE)#
		{#
		cat("\nNote: force_sparse is set to TRUE; length(states_list)=", length(states_list), "\n", sep="")#
		}#
	########################################################
	# Load the phylogenetic tree#
	########################################################
	trfn = np(inputs$trfn)#
	#phy = read.tree(file=trfn)#
	phy = check_trfn(trfn=trfn)#
	########################################################
	# Read the stratification/distances input files, if any#
	########################################################
	inputs = readfiles_BioGeoBEARS_run(inputs=inputs)#
	########################################################
	# FROM CALC_LOGLIKE_SP_FOR_OPTIM()#
	########################################################
	# Set the dispersal and extinction rate#
	d = BioGeoBEARS_model_object@params_table["d","est"]#
	e = BioGeoBEARS_model_object@params_table["e","est"]#
	a = BioGeoBEARS_model_object@params_table["a","est"]#
	########################################################
	########################################################
	# Do branch-length exponentiation if desired#
	########################################################
	########################################################
	b = BioGeoBEARS_model_object@params_table["b","est"]#
	# Modify the edge.lengths#
	phy$edge.length = phy$edge.length ^ b#
	# Make sure this doesn't duplicate a previous "^b", e.g.#
	# the summarization step in bears_optim_run#
#
	########################################################
	########################################################
	# Do distance-dependence and dispersal multipliers matrix#
	########################################################
	########################################################
	# Equal dispersal in all directions (unconstrained)#
	# Equal extinction probability for all areas#
	areas = areas_list#
	# If there is a distance matrix, use the timeperiod_i'th one #
	# By default, this is 1 (non-stratified analysis, here)#
	# otherwise, it could be any timeperiod_i#
	if ( (is.null(BioGeoBEARS_run_object$list_of_distances_mats) == FALSE))#
		{#
		distances_mat = BioGeoBEARS_run_object$list_of_distances_mats[[timeperiod_i]]#
		} else {#
		# Default is all areas effectively equidistant#
		distances_mat = matrix(1, nrow=length(areas), ncol=length(areas))#
		}#
#
	# Get the exponent on distance, apply to distances matrix#
	x = BioGeoBEARS_model_object@params_table["x","est"]#
	dispersal_multipliers_matrix = distances_mat ^ x#
	# Environmental distances#
	if ( (is.null(BioGeoBEARS_run_object$list_of_envdistances_mats) == FALSE))#
		{#
		envdistances_mat = BioGeoBEARS_run_object$list_of_envdistances_mats[[timeperiod_i]]#
		} else {#
		# Default is all areas effectively equidistant#
		envdistances_mat = matrix(1, nrow=length(areas), ncol=length(areas))#
		}#
#
	# Get the exponent on environmental distance, apply to distances matrix#
	n = BioGeoBEARS_model_object@params_table["n","est"]#
	dispersal_multipliers_matrix = dispersal_multipliers_matrix * envdistances_mat ^ n#
	# Apply manual dispersal multipliers, if any#
	# If there is a manual dispersal multipliers matrix, use the first one #
	# (non-stratified analysis, here)#
	if ( (is.null(BioGeoBEARS_run_object$list_of_dispersal_multipliers_mats) == FALSE))#
		{#
		manual_dispersal_multipliers_matrix = BioGeoBEARS_run_object$list_of_dispersal_multipliers_mats[[timeperiod_i]]#
		} else {#
		# Default is all areas effectively equidistant#
		manual_dispersal_multipliers_matrix = matrix(1, nrow=length(areas), ncol=length(areas))#
		}#
	# Get the exponent on manual dispersal multipliers#
	w = BioGeoBEARS_model_object@params_table["w","est"]#
#
	# Apply element-wise#
	dispersal_multipliers_matrix = dispersal_multipliers_matrix * manual_dispersal_multipliers_matrix ^ w#
#
	########################################################
	# multiply parameter d by dispersal_multipliers_matrix#
	########################################################
	dmat_times_d = dispersal_multipliers_matrix * matrix(d, nrow=length(areas), ncol=length(areas))#
	amat = dispersal_multipliers_matrix * matrix(a, nrow=length(areas), ncol=length(areas))#
	########################################################
	########################################################
	# Do area-dependence and extinction multipliers list#
	########################################################
	########################################################
	if ( (is.null(BioGeoBEARS_run_object$list_of_area_of_areas) == FALSE))#
		{#
		area_of_areas = BioGeoBEARS_run_object$list_of_area_of_areas[[timeperiod_i]]#
		} else {#
		# Default is all areas effectively equidistant#
		area_of_areas = rep(1, length(areas))#
		}#
	# Get the exponent on extinction, apply to extinction modifiers	#
	u = BioGeoBEARS_model_object@params_table["u","est"]#
	extinction_modifier_list = area_of_areas ^ (1 * u)#
	# Apply to extinction rate#
	elist = extinction_modifier_list * rep(e, length(areas))#
	# Set up the instantaneous rate matrix (Q matrix)#
	# someday we'll have to put "a" (anagenic range-switching) in here...#
	Qmat = rcpp_states_list_to_DEmat(areas_list=areas_list, states_list=states_list, dmat=dmat_times_d, elist=elist, amat=amat, include_null_range=TRUE, normalize_TF=TRUE, makeCOO_TF=force_sparse)#
#
	########################################################
	# Cladogenic model#
	########################################################
	j = BioGeoBEARS_model_object@params_table["j","est"]#
	ysv = BioGeoBEARS_model_object@params_table["ysv","est"]#
	ys = BioGeoBEARS_model_object@params_table["ys","est"]#
	v = BioGeoBEARS_model_object@params_table["v","est"]#
	y = BioGeoBEARS_model_object@params_table["y","est"]#
	s = BioGeoBEARS_model_object@params_table["s","est"]#
	sum_SPweights = y + s + j + v#
	maxent_constraint_01 = BioGeoBEARS_model_object@params_table["mx01","est"]#
	# Text version of speciation matrix	#
	maxent_constraint_01v = BioGeoBEARS_model_object@params_table["mx01v","est"]#
	#spPmat = symbolic_to_relprob_matrix_sp(spmat, cellsplit="\\+", mergesym="*", ys=ys, j=j, v=v, maxent_constraint_01=maxent_constraint_01, maxent_constraint_01v=maxent_constraint_01v, max_numareas=max_numareas)#
	# Set the parameter controlling the size distribution of #
	# the smaller descendant species#
	maxent01s_param = BioGeoBEARS_model_object@params_table["mx01s","est"]#
	maxent01v_param = BioGeoBEARS_model_object@params_table["mx01v","est"]#
	maxent01j_param = BioGeoBEARS_model_object@params_table["mx01j","est"]#
	maxent01y_param = BioGeoBEARS_model_object@params_table["mx01y","est"]#
	# Cladogenesis model inputs#
	spPmat_inputs = NULL#
#
	# Note that this gets the dispersal multipliers matrix, which is applied to #
	# e.g. the j events, NOT the dmat_times_d above which is d*dispersal_multipliers_matrix#
	dmat = dispersal_multipliers_matrix#
	spPmat_inputs$dmat = dmat#
#
	states_indices = states_list#
#
	# shorten the states_indices by 1 (cutting the #
	# null range state from the speciation matrix)#
	if (include_null_range == TRUE)#
		{#
		states_indices[1] = NULL#
		} # END if (include_null_range == TRUE)#
	spPmat_inputs$l = states_indices#
	spPmat_inputs$s = s#
	spPmat_inputs$v = v#
	spPmat_inputs$j = j#
	spPmat_inputs$y = y#
	spPmat_inputs$maxent01s_param = maxent01s_param#
	spPmat_inputs$maxent01v_param = maxent01v_param#
	spPmat_inputs$maxent01j_param = maxent01j_param#
	spPmat_inputs$maxent01y_param = maxent01y_param#
	########################################################
	# From calc_loglike_sp()#
	########################################################
#
	# defaults#
	calc_ancprobs = TRUE#
	cppSpMethod = 3#
	printmat = FALSE#
	# Fix "l" (which is states_indices, i.e. a list of lists of state_indices)#
	# so that there is no "null geographic range", i.e. no "_", no "-", no "NA"#
	if ( is.null(spPmat_inputs)==FALSE )#
		{#
		spPmat_inputs$l[spPmat_inputs$l == c("_")] = NULL#
		spPmat_inputs$l[spPmat_inputs$l == c("-")] = NULL#
		spPmat_inputs$l[spPmat_inputs$l == c("-1")] = NULL#
		#spPmat_inputs$l[spPmat_inputs$l == c(-1)] = NULL#
		}#
	l = spPmat_inputs$l		# states_indices#
	s = spPmat_inputs$s#
	v = spPmat_inputs$v#
	j = spPmat_inputs$j#
	y = spPmat_inputs$y#
	# Take the max of the indices of the possible areas, and add 1#
	# numareas = max(unlist(spPmat_inputs$l), na.rm=TRUE) + 1 # old, bogus#
	numareas = max(sapply(X=spPmat_inputs$l, FUN=length), na.rm=TRUE) + 0#
	maxent01s_param = spPmat_inputs$maxent01s_param#
	maxent01v_param = spPmat_inputs$maxent01v_param#
	maxent01j_param = spPmat_inputs$maxent01j_param#
	maxent01y_param = spPmat_inputs$maxent01y_param#
	maxent01s = relative_probabilities_of_subsets(max_numareas=numareas, maxent_constraint_01=maxent01s_param, NA_val=0)#
	maxent01v = relative_probabilities_of_vicariants(max_numareas=numareas, maxent_constraint_01v=maxent01v_param, NA_val=0)#
	maxent01j = relative_probabilities_of_subsets(max_numareas=numareas, maxent_constraint_01=maxent01j_param, NA_val=0)#
	maxent01y = relative_probabilities_of_subsets(max_numareas=numareas, maxent_constraint_01=maxent01y_param, NA_val=0)#
#
	# You really need a list of sizes here:#
	# Matrix of probs for each ancsize#
	maxprob_as_function_of_ancsize_and_decsize = mapply(FUN=max, maxent01s, maxent01v, maxent01j, maxent01y, MoreArgs=list(na.rm=TRUE))#
	maxprob_as_function_of_ancsize_and_decsize = matrix(data=maxprob_as_function_of_ancsize_and_decsize, nrow=nrow(maxent01s), ncol=ncol(maxent01s))#
	maxprob_as_function_of_ancsize_and_decsize[maxprob_as_function_of_ancsize_and_decsize > 0] = 1#
	maxprob_as_function_of_ancsize_and_decsize[maxprob_as_function_of_ancsize_and_decsize <= 0] = 0#
	# Now, go through, and make a list of the max minsize for each decsize#
	max_minsize_as_function_of_ancsize = apply(X=maxprob_as_function_of_ancsize_and_decsize, MARGIN=1, FUN=maxsize)#
	tmpca_1 = rep(1, (numstates-1))#
	tmpcb_1 = rep(1, (numstates-1))#
	COO_weights_columnar = rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs=tmpca_1, Rcpp_rightprobs=tmpcb_1, l=l, s=s, v=v, j=j, y=y, dmat=dispersal_multipliers_matrix, maxent01s=maxent01s, maxent01v=maxent01v, maxent01j=maxent01j, maxent01y=maxent01y, max_minsize_as_function_of_ancsize=max_minsize_as_function_of_ancsize, printmat=printmat)#
	# combine with C++ function#
	# This causes an error with spPmat=NULL; spPmat_inputs=NULL; use_cpp=TRUE; sparse=FALSE#
	# i.e. gives 16 states with a 0 on the end, rather than 15 states#
	#Rsp_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar=COO_weights_columnar, numstates=numstates)#
	# This gives 15 states#
	Rsp_rowsums = rcpp_calc_rowsums_for_COOweights_columnar(COO_weights_columnar=COO_weights_columnar)#
	Qmat#
	rowSums(Qmat)	# yep, they sum to 0#
	max(rowSums(Qmat))#
	COO_weights_columnar#
	Rsp_rowsums#
	returned_mats = NULL#
	returned_mats$states_list = states_list#
	returned_mats$spPmat_inputs = spPmat_inputs#
	returned_mats$areas_list = areas_list#
	returned_mats$dmat = dmat#
	returned_mats$Qmat = Qmat#
	returned_mats$COO_weights_columnar = COO_weights_columnar#
	returned_mats$Rsp_rowsums = Rsp_rowsums#
	return(returned_mats)#
	}
res$inputs = define_BioGeoBEARS_run()#
	res$outputs = res$inputs$BioGeoBEARS_model_object#
	res#
	# Produces stop error#
	get_Qmat_COOmat_from_BioGeoBEARS_run_object(res, numstates=NULL, include_null_range=TRUE, max_range_size=NULL)#
	# Works:#
	# Get the dmat (trivial case, non-stratified Psychotria example)#
	returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(res, numstates=NULL, max_range_size=4)#
	returned_mats#
	names(returned_mats)#
	# Also works:#
	res$inputs$max_range_size = 4#
	returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(res, numstates=NULL, max_range_size=NULL)#
	returned_mats#
	names(returned_mats)
# Set up a BioGeoBEARS_run_object#
	BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	# Produces stop error#
	get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, include_null_range=TRUE, max_range_size=NULL)
returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, max_range_size=4)#
	returned_mats#
	names(returned_mats)
BioGeoBEARS_run_object$max_range_size = 4#
	returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object, BioGeoBEARS_model_object=NULL, numstates=NULL, max_range_size=NULL)#
	returned_mats#
	names(returned_mats)
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	areas = c("K", "O", "M", "H")#
	max_range_size = length(areas)#
	include_null_range = TRUE#
	states_list = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
	areas = c("K", "O", "M", "H")#
	max_range_size = length(areas)#
	include_null_range = TRUE#
	dispersal_multipliers_matrix = matrix(data=1, nrow=4, ncol=4)#
	states_list = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)#
	spPmat_inputs = get_spPmat_inputs_from_BGB(BioGeoBEARS_run_object=BioGeoBEARS_run_object, states_list=states_list, dispersal_multipliers_matrix=dispersal_multipliers_matrix)#
	spPmat_inputs
gsbu
gsub
list_of_strings = NULL#
	list_of_strings[[1]] = c("A,,B", "B,C,,D,,,E,,,,F")#
	list_of_strings[[2]] = c(",A,,B", "B,C,,D,,,E,,,,F")#
	list_of_strings[[3]] = c(",,,A,,B", "B,C,,D,,,E,,,,F")#
	list_of_strings[[4]] = c(",,,A,,B", "B,C,,D,,,E,,,,F,")#
	list_of_strings[[5]] = c(",,,A,,B", "B,C,,D,,,E,,,,F,,,")#
	list_of_strings#
	OTUs_list_of_lists_reduced = remove_multiple_commas_from_strings_in_list(list_of_strings)#
	OTUs_list_of_lists_reduced
library(stringr)
str_count
possible_ranges_list_txt = c("A", "AB", "ABC")#
	colors_list_for_states = c("red", "orange", "white")#
	MLstates = c("ABC", "AB", "AB", "A", "A", "A", "ABC")#
	rangestxt_to_colors(possible_ranges_list_txt, colors_list_for_states, MLstates)
node_coords
areanames = c("K", "O", "M", "H")#
	max_range_size = 4#
	plot_null_range = TRUE#
	states_list_0based=rcpp_areas_list_to_states_list(areas=areanames, maxareas=max_range_size, include_null_range=plot_null_range)#
	get_colors_for_states_list_0based(areanames, states_list_0based=NULL, max_range_size=NA, plot_null_range=FALSE)
par
ladderize
ladderize(tr, right=TRUE)#
	tr$edge#
	ladderize(tr, right=FALSE)#
	tr$edge#
	ladderize_and_reorder(tr, right=TRUE)#
	tr$edge#
	ladderize_and_reorder(tr, right=FALSE)#
	tr$edge
tr = read.tree(file="", text="((human:1,chimp:1):1,gorilla:2);")#
	ltr = ladderize(tr, right=TRUE)#
	ltr$edge#
	ltr = ladderize(tr, right=FALSE)#
	ltr$edge#
	ltr = ladderize_and_reorder(tr, right=TRUE)#
	ltr$edge#
	ltr = ladderize_and_reorder(tr, right=FALSE)#
	ltr$edge
math
?match
prt()
tr = ape::read.tree(file="", text="((human:1,chimp:1):1,gorilla:2);")#
	ltr1 = ladderize_and_reorder(tr, right=TRUE)#
	ltr2 = ladderize_and_reorder(tr, right=FALSE)#
#
	# Compare the tree tables#
	prt(ltr1, printflag=FALSE, get_tipnames=TRUE)#
	prt(ltr2, printflag=FALSE, get_tipnames=TRUE)#
	# Get the matching#
	indexes_to_convert_tr2nodes_to_tr1 = ordernodes(tr1, tr2)#
	indexes_to_convert_tr2nodes_to_tr1
# Make 2 differently-rotated trees#
	tr = ape::read.tree(file="", text="((human:1,chimp:1):1,gorilla:2);")#
	ltr1 = ladderize_and_reorder(tr, right=TRUE)#
	ltr2 = ladderize_and_reorder(tr, right=FALSE)#
#
	# Compare the tree tables#
	prt(ltr1, printflag=FALSE, get_tipnames=TRUE)#
	prt(ltr2, printflag=FALSE, get_tipnames=TRUE)#
	# Get the matching#
	indexes_to_convert_tr2nodes_to_tr1 = ordernodes(tr1=ltr1, tr2=ltr2)#
	indexes_to_convert_tr2nodes_to_tr1
tr1 = ape::read.tree(file="", text="((human:1,chimp:1):1,gorilla:2);")#
	tr2 = ape::read.tree(file="", text="(((human:1,chimp:1):1,gorilla:2):1,orang:3);")#
#
	# Compare the tree tables#
	prt(tr1, printflag=FALSE, get_tipnames=TRUE)#
	prt(tr2, printflag=FALSE, get_tipnames=TRUE)#
	# Get the matching#
	indexes_to_convert_tr2nodes_to_tr1 = ordernodes(tr1=tr1, tr2=tr2)#
	indexes_to_convert_tr2nodes_to_tr1
indexes_to_convert_tr1nodes_to_tr2 = ordernodes(tr1=tr2, tr2=tr1)#
	indexes_to_convert_tr1nodes_to_tr2
?treedist
?ape
?treedist
source("http://phylo.wdfiles.com/local--files/biogeobears/calc_loglike_sp_v01.R")
/drives/GDrive/__GDrive_projects/2019-02-05_Moos_Crypto/_r4_Crypto_lin/DEC_M0_all_models_v2
install.packages("TeachingDemos")
library(BioGeoBEARS)
numstates_from_numareas(numareas=2, maxareas=2, include_null_range=TRUE)
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)
numstates_from_numareas(numareas=11, maxareas=11, include_null_range=TRUE)
numstates_from_numareas(numareas=26, maxareas=26, include_null_range=TRUE)
numstates_from_numareas(numareas=26, maxareas=2, include_null_range=TRUE)
26*26
26*25
numstates_from_numareas(numareas=26, maxareas=3, include_null_range=TRUE)
numstates_from_numareas(numareas=26, maxareas=4, include_null_range=TRUE)
numstates_from_numareas(numareas=26, maxareas=2, include_null_range=TRUE)
# Load the package (after installation, see above).#
library(GenSA)    # GenSA is better than optimx (although somewhat slower)#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
#
########################################################
# 2018-10-10 update: I have been putting the #
# updates on CRAN/GitHub#
# You should use:#
# rexpokit version 0.26.6 from CRAN#
# cladoRcpp version 0.15 from CRAN#
# BioGeoBEARS version 1.1 from GitHub, install with:#
# library(devtools)#
# devtools::install_github(repo="nmatzke/BioGeoBEARS")#
########################################################
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
#
#########################################################
# TO GET THE OPTIMX/OPTIM FIX, AND THE UPPASS FIX, #
# SOURCE THE REVISED FUNCTIONS WITH THESE COMMANDS#
##
# CRUCIAL CRUCIAL CRUCIAL: #
# YOU HAVE TO RUN THE SOURCE COMMANDS AFTER #
# *EVERY TIME* YOU DO library(BioGeoBEARS). THE CHANGES ARE NOT "PERMANENT", #
# THEY HAVE TO BE MADE EACH TIME.  IF YOU ARE GOING TO BE OFFLINE, #
# YOU CAN DOWNLOAD EACH .R FILE TO YOUR HARD DRIVE AND REFER THE source()#
# COMMANDS TO THE FULL PATH AND FILENAME OF EACH FILE ON YOUR#
# LOCAL SYSTEM INSTEAD.#
#########################################################
# library(BioGeoBEARS)#
# source("http://phylo.wdfiles.com/local--files/biogeobears/cladoRcpp.R") # (needed now that traits model added; source FIRST!)#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_add_fossils_randomly_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_basics_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_calc_transition_matrices_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_classes_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_detection_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_DNA_cladogenesis_sim_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_extract_Qmat_COOmat_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_generics_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_models_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_on_multiple_trees_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_plots_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_readwrite_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_simulate_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_SSEsim_makePlots_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_SSEsim_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_stochastic_mapping_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_stratified_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_univ_model_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/calc_uppass_probs_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/calc_loglike_sp_v01.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/get_stratified_subbranch_top_downpass_likelihoods_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/runBSM_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/stochastic_map_given_inputs.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/summarize_BSM_tables_v1.R")#
# source("http://phylo.wdfiles.com/local--files/biogeobears/BioGeoBEARS_traits_v1.R") # added traits model#
# calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
# calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
    # slight speedup hopefully#
#
########################################################
# Local source()-ing method -- uses BioGeoBEARS sourceall() function #
# on a directory of .R files, so you don't have to type them out.#
# The directories here are on my machine, you would have to make a #
# directory, save the .R files there, and refer to them.#
##
# NOTE: it's best to source the "cladoRcpp.R" update first, to avoid warnings like this:#
###
## Note: possible error in 'rcpp_calc_anclikes_sp_COOweights_faster(Rcpp_leftprobs = tmpca_1, ': #
##         unused arguments (m = m, m_null_range = include_null_range, jts_matrix = jts_matrix) #
###
##
# TO USE: Delete or comment out the 'source("http://...")' commands above, and un-comment#
#              the below...#
#########################################################################
# Un-comment (and fix directory paths) to use:#
#library(BioGeoBEARS)#
#source("/drives/Dropbox/_njm/__packages/cladoRcpp_setup/cladoRcpp.R")#
#sourceall("/drives/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#calc_loglike_sp = compiler::cmpfun(calc_loglike_sp_prebyte)    # crucial to fix bug in uppass calculations#
#calc_independent_likelihoods_on_each_branch = compiler::cmpfun(calc_independent_likelihoods_on_each_branch_prebyte)#
#########################################################################
#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
wd = np("~")#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = np(paste(addslash(extdata_dir), "Psychotria_5.2.newick", sep=""))#
#
# Look at the raw Newick file:#
moref(trfn)#
#
# Look at your phylogeny:#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example Psychotria phylogeny from Ree & Smith (2008)")#
axisPhylo() # plots timescale#
#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian Psychotria#
# (from Ree & Smith 2008)#
geogfn = np(paste(addslash(extdata_dir), "Psychotria_geog.data", sep=""))#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 4#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "Psychotria_DEC_M0_unconstrained_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
#BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
#BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
#BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "Psychotria_DEC+J_M0_unconstrained_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }
pdffn = "Psychotria_DEC_vs_DEC+J_M0_unconstrained_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DEC#
########################################################
analysis_titletxt ="BioGeoBEARS DEC on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDEC#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DECJ#
########################################################
analysis_titletxt ="BioGeoBEARS DEC+J on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDECj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it
dev.off()
pdffn = "Psychotria_DEC_vs_DEC+J_M0_unconstrained_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DEC#
########################################################
analysis_titletxt ="BioGeoBEARS DEC on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDEC#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DECJ#
########################################################
analysis_titletxt ="BioGeoBEARS DEC+J on Psychotria M0_unconstrained"#
#
# Setup#
results_object = resDECj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it
26 * 25
26 * 25/3
26 * 25/2
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_tables
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table
d = 2.1
distance=30
d * distance^-1
d
d * distance^-2
d * distance^0
d
d * 300^0
d * 300000^0
library(phylosignal)
? phyloCorrelogram
data(navic)#
pc <- phyloCorrelogram(navic)#
plot(pc)
navic
? phyloCorrelogram
x=distTips(x=navic, method="patristic")
library(adephylo)
x=distTips(x=navic, method="patristic")
x
numsamps = 1000#
#
tipnums = matrix(data=NA, nrow=numsamps, ncol=2)#
for (i in 1:nrow(tipnums))#
	{#
	tipnums[i,] = sample(x=1:length(tr3$tip.label), size=2, replace=FALSE, prob=NULL)#
	}#
head(tipnums)
numsamps = 1000#
numtips = length(tr3$tip.label)#
#
tipnums = matrix(data=NA, nrow=numsamps, ncol=2)#
for (i in 1:nrow(tipnums))#
	{#
	tipnums[i,] = sample(x=1:numtips, size=2, replace=FALSE, prob=NULL)#
	}#
head(tipnums)#
#
# semivariance:#
# This is just 0.5 * (pairwise_difference or pairwise_distance)^2#
#
distances = rep(NA, times=numsamps)#
difference = rep(NA, times=numsamps)#
semivariance = rep(NA, times=numsamps)#
#
for (i in 1:nrow(tipnums))#
	{#
	tipnum1 = tipnums[i,1]#
	tipnum2 = tipnums[i,2]#
	tmpdist = distmat2[tipnum1, tipnum2]#
	tmpdiff = x[tipnum1] - x[tipnum2]#
	tmp_semivariance = 0.5 * tmpdiff^2#
	distances[i] = tmpdist#
	difference[i] = tmpdiff#
	semivariance[i] = tmp_semivariance#
	}
sd<-boxplot(dummydata)#
str(sd)
boxplot(x)
x
1-(5/6)^4
1 - (1-(1/6)^2)^24
/drives/GDrive/z_help/jimeiyuan93_BGB_optimx/AARs.Rmd
ls()
fn="/drives/GDrive/z_help/jimeiyuan93_BGB_optimx/AARs.Rmd"
load(fn)
remove.packages("BioGeoBEARS")#
detach("package:BioGeoBEARS")#
library(BioGeoBEARS)
library(phylobase)#
#
library(devtools)#
install_local(path="/GitHub/BioGeoBEARS", dependencies=FALSE)#
#
getareas_from_tipranges_object#
#
getareanames_from_tipranges_object
library(BioGeoBEARS)#
#
getareas_from_tipranges_object#
#
getareanames_from_tipranges_object
source('/GitHub/BioGeoBEARS/R/BioGeoBEARS_extract_Qmat_COOmat_v1.R', chdir = TRUE)
library(BioGeoBEARS)#
#
getareas_from_tipranges_object#
#
getareanames_from_tipranges_object
source('/GitHub/BioGeoBEARS.Rcheck/00_pkg_src/BioGeoBEARS/R/BioGeoBEARS_basics_v1.R', chdir = TRUE)
getareanames_from_tipranges_object
# Load the package (after installation, see above).#
library(GenSA)    # GenSA is better than optimx (although somewhat slower)#
library(optimx)    # GenSA is better than optimx (although somewhat slower)#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
#
########################################################
# 2018-10-10 update: I have been putting the #
# updates on CRAN/GitHub#
# You should use:#
# rexpokit version 0.26.6 from CRAN#
# cladoRcpp version 0.15 from CRAN#
# BioGeoBEARS version 1.1 from GitHub, install with:#
# library(devtools)#
# devtools::install_github(repo="nmatzke/BioGeoBEARS")#
########################################################
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
# wd = "/drives/GDrive/z_help/Furnariidae_Bio_Geo/BSM_small/M3_areas_allowed/"#
# setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
#
wd = slashslash(paste0(addslash(extdata_dir), "/examples/BSM_3taxa/M3_areas_allowed/"))#
setwd(wd)#
#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian 3taxa#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = "tree.newick"#
#
# Look at the raw Newick file:#
moref(trfn)#
pdffn = "tree.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
# Look at your phylogeny:#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example tree")#
axisPhylo() # plots timescale#
dev.off()#
#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian 3taxa#
# (from Ree & Smith 2008)#
geogfn = "geog.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 3#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed_noC.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "3taxa_DEC_M3_areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }#
#
########################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed_noC.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "3taxa_DEC+J_M3_areas_allowed_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }#
#
########################################################
# PDF plots#
########################################################
pdffn = "3taxa_DEC_vs_DEC+J_M3_areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DEC#
########################################################
analysis_titletxt ="BioGeoBEARS DEC on 3taxa M3_areas_allowed_unconstrained"#
#
# Setup#
results_object = resDEC#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DECJ#
########################################################
analysis_titletxt ="BioGeoBEARS DEC+J on 3taxa M3_areas_allowed_unconstrained"#
#
# Setup#
results_object = resDECj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it#
#
########################################################
########################################################
# DIVALIKE AND DIVALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DIVALIKE" model is not identical with #
# Ronquist (1997)'s parsimony DIVA. It is a likelihood#
# interpretation of DIVA, constructed by modelling DIVA's#
# processes the way DEC does, but only allowing the #
# processes DIVA allows (widespread vicariance: yes; subset#
# sympatry: no; see Ronquist & Sanmartin 2011, Figure 4).#
##
# DIVALIKE is a likelihood interpretation of parsimony#
# DIVA, and it is "like DIVA" -- similar to, but not#
# identical to, parsimony DIVA.#
##
# I thus now call the model "DIVALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run DIVALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed_noC.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE model#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "3taxa_DIVALIKE_M3_areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDIVALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKE = res#
    }#
#
########################################################
# Run DIVALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed_noC.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDIVALIKE$outputs@params_table["d","est"]#
estart = resDIVALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# Add jump dispersal/founder-event speciation#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under DIVALIKE+J, the max of "j" should be 2, not 3 (as is default in DEC+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 1.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "3taxa_DIVALIKE+J_M3_areas_allowed_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDIVALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKEj = res#
    }#
#
pdffn = "3taxa_DIVALIKE_vs_DIVALIKE+J_M3_areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DIVALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE on 3taxa M3_areas_allowed_unconstrained"#
#
# Setup#
results_object = resDIVALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DIVALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE+J on 3taxa M3_areas_allowed_unconstrained"#
#
# Setup#
results_object = resDIVALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
########################################################
########################################################
# BAYAREALIKE AND BAYAREALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: As with DIVA, the BioGeoBEARS BayArea-like model is #
# not identical with the full Bayesian model implemented #
# in the "BayArea" program of Landis et al. (2013). #
##
# Instead, this is a simplified likelihood interpretation#
# of the model.  Basically, in BayArea and BioGeoBEARS-BAYAREALIKE, #
# "d" and "e" work like they do in the DEC model of Lagrange #
# (and BioGeoBEARS), and then BayArea's cladogenesis assumption#
# (which is that nothing in particular happens at cladogenesis) is #
# replicated by BioGeoBEARS.#
##
# This leaves out 3 important things that are in BayArea:#
# 1. Distance dependence (you can add this with a distances #
#    matrix + the "x" parameter in BioGeoBEARS, however)#
# 2. A correction for disallowing "e" events that drive#
#    a species extinct (a null geographic range)#
# 3. The neat Bayesian sampling of histories, which allows#
#    analyses on large numbers of areas.#
##
# The main purpose of having a "BAYAREALIKE" model is #
# to test the importance of the cladogenesis model on #
# particular datasets. Does it help or hurt the data #
# likelihood if there is no special cladogenesis process?#
# #
# BAYAREALIKE is a likelihood interpretation of BayArea,#
# and it is "like BayArea" -- similar to, but not#
# identical to, Bayesian BayArea.#
# I thus now call the model "BAYAREALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run BAYAREALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed_noC.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE model#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# Check the inputs#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "3taxa_BAYAREALIKE_M3_areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resBAYAREALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKE = res#
    }#
#
########################################################
# Run BAYAREALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed_noC.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resBAYAREALIKE$outputs@params_table["d","est"]#
estart = resBAYAREALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# *DO* allow jump dispersal/founder-event speciation (set the starting value close to 0)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under BAYAREALIKE+J, the max of "j" should be 1, not 3 (as is default in DEC+J) or 2 (as in DIVALIKE+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# NOTE (NJM, 2014-04): BAYAREALIKE+J seems to crash on some computers, usually Windows #
# machines. I can't replicate this on my Mac machines, but it is almost certainly#
# just some precision under-run issue, when optim/optimx tries some parameter value #
# just below zero.  The "min" and "max" options on each parameter are supposed to#
# prevent this, but apparently optim/optimx sometimes go slightly beyond #
# these limits.  Anyway, if you get a crash, try raising "min" and lowering "max" #
# slightly for each parameter:#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "3taxa_BAYAREALIKE+J_M3_areas_allowed_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resBAYAREALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKEj = res#
    }#
#
pdffn = "3taxa_BAYAREALIKE_vs_BAYAREALIKE+J_M3_areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - BAYAREALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS BAYAREALIKE on 3taxa M3_areas_allowed_unconstrained"#
#
# Setup#
results_object = resBAYAREALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - BAYAREALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS BAYAREALIKE+J on 3taxa M3_areas_allowed_unconstrained"#
#
# Setup#
results_object = resBAYAREALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
##########################################################################
##########################################################################
##########################################################################
##########################################################################
# #
# CALCULATE SUMMARY STATISTICS TO COMPARE#
# DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J#
# #
##########################################################################
##########################################################################
##########################################################################
##########################################################################
#
##########################################################################
##########################################################################
# REQUIRED READING:#
##
# Practical advice / notes / basic principles on statistical model #
#    comparison in general, and in BioGeoBEARS:#
# http://phylo.wikidot.com/advice-on-statistical-model-comparison-in-biogeobears#
##########################################################################
##########################################################################
#
# Set up empty tables to hold the statistical results#
restable = NULL#
teststable = NULL#
#
########################################################
# Statistics -- DEC vs. DEC+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDEC)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDECj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# DEC, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDEC, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# DEC+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDECj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
# The null hypothesis for a Likelihood Ratio Test (LRT) is that two models#
# confer the same likelihood on the data. See: Brian O'Meara's webpage:#
# http://www.brianomeara.info/tutorials/aic#
# ...for an intro to LRT, AIC, and AICc#
#
rbind(res2, res1)#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
########################################################
# Statistics -- DIVALIKE vs. DIVALIKE+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKE)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKEj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# DIVALIKE, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# DIVALIKE+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
rbind(res2, res1)#
conditional_format_table(stats)#
#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
########################################################
# Statistics -- BAYAREALIKE vs. BAYAREALIKE+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKE)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKEj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# BAYAREALIKE, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# BAYAREALIKE+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
rbind(res2, res1)#
conditional_format_table(stats)#
#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
##########################################################################
# ASSEMBLE RESULTS TABLES: DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J#
##########################################################################
teststable$alt = c("DEC+J", "DIVALIKE+J", "BAYAREALIKE+J")#
teststable$null = c("DEC", "DIVALIKE", "BAYAREALIKE")#
row.names(restable) = c("DEC", "DEC+J", "DIVALIKE", "DIVALIKE+J", "BAYAREALIKE", "BAYAREALIKE+J")#
restable = put_jcol_after_ecol(restable)#
restable#
#
# Look at the results!!#
restable#
teststable#
#
########################################################
# Save the results tables for later -- check for e.g.#
# convergence issues#
########################################################
#
# Loads to "restable"#
save(restable, file="restable_v1.Rdata")#
load(file="restable_v1.Rdata")#
#
# Loads to "teststable"#
save(teststable, file="teststable_v1.Rdata")#
load(file="teststable_v1.Rdata")#
#
# Also save to text files#
write.table(restable, file="restable.txt", quote=FALSE, sep="\t")#
write.table(unlist_df(teststable), file="teststable.txt", quote=FALSE, sep="\t")#
#
########################################################
# Model weights of all six models#
########################################################
restable2 = restable#
#
# With AICs:#
AICtable = calc_AIC_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams)#
restable = cbind(restable, AICtable)#
restable_AIC_rellike = AkaikeWeights_on_summary_table(restable=restable, colname_to_use="AIC")#
restable_AIC_rellike = put_jcol_after_ecol(restable_AIC_rellike)#
restable_AIC_rellike#
#
# With AICcs -- factors in sample size#
# samplesize = length(tr$tip.label)#
# AICtable = calc_AICc_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams, samplesize=samplesize)#
# restable2 = cbind(restable2, AICtable)#
# restable_AICc_rellike = AkaikeWeights_on_summary_table(restable=restable2, colname_to_use="AICc")#
# restable_AICc_rellike = put_jcol_after_ecol(restable_AICc_rellike)#
# restable_AICc_rellike#
#
# Also save to text files#
write.table(restable_AIC_rellike, file="restable_AIC_rellike.txt", quote=FALSE, sep="\t")#
#write.table(restable_AICc_rellike, file="restable_AICc_rellike.txt", quote=FALSE, sep="\t")#
#
# Save with nice conditional formatting#
write.table(conditional_format_table(restable_AIC_rellike), file="restable_AIC_rellike_formatted.txt", quote=FALSE, sep="\t")#
#write.table(conditional_format_table(restable_AICc_rellike), file="restable_AICc_rellike_formatted.txt", quote=FALSE, sep="\t")
# Load the package (after installation, see above).#
library(GenSA)    # GenSA is better than optimx (although somewhat slower)#
library(optimx)    # GenSA is better than optimx (although somewhat slower)#
library(FD)       # for FD::maxent() (make sure this is up-to-date)#
library(snow)     # (if you want to use multicore functionality; some systems/R versions prefer library(parallel), try either)#
library(parallel)#
#
########################################################
# 2018-10-10 update: I have been putting the #
# updates on CRAN/GitHub#
# You should use:#
# rexpokit version 0.26.6 from CRAN#
# cladoRcpp version 0.15 from CRAN#
# BioGeoBEARS version 1.1 from GitHub, install with:#
# library(devtools)#
# devtools::install_github(repo="nmatzke/BioGeoBEARS")#
########################################################
library(rexpokit)#
library(cladoRcpp)#
library(BioGeoBEARS)#
########################################################
# SETUP: YOUR WORKING DIRECTORY#
########################################################
# You will need to set your working directory to match your local system#
#
# Note these very handy functions!#
# Command "setwd(x)" sets your working directory#
# Command "getwd()" gets your working directory and tells you what it is.#
# Command "list.files()" lists the files in your working directory#
# To get help on any command, use "?".  E.g., "?list.files"#
#
# Set your working directory for output files#
# default here is your home directory ("~")#
# Change this as you like#
# wd = slashslash(paste0(addslash(extdata_dir), "/examples/BSM_3taxa/M3areas_allowed/"))#
# setwd(wd)#
#
wd = "/GitHub/BioGeoBEARS/inst/extdata/examples/BSM_3taxa/M3areas_allowed/"#
setwd(wd)#
#
# Double-check your working directory with getwd()#
getwd()#
#
########################################################
# SETUP: Extension data directory#
########################################################
# When R packages contain extra files, they are stored in the "extdata" directory #
# inside the installed package.#
##
# BioGeoBEARS contains various example files and scripts in its extdata directory.#
# #
# Each computer operating system might install BioGeoBEARS in a different place, #
# depending on your OS and settings. #
# #
# However, you can find the extdata directory like this:#
extdata_dir = np(system.file("extdata", package="BioGeoBEARS"))#
extdata_dir#
list.files(extdata_dir)#
# "system.file" looks in the directory of a specified package (in this case BioGeoBEARS)#
# The function "np" is just a shortcut for normalizePath(), which converts the #
# path to the format appropriate for your system (e.g., Mac/Linux use "/", but #
# Windows uses "\\", if memory serves).#
#
# Even when using your own data files, you should KEEP these commands in your #
# script, since the plot_BioGeoBEARS_results function needs a script from the #
# extdata directory to calculate the positions of "corners" on the plot. This cannot#
# be made into a straight up BioGeoBEARS function because it uses C routines #
# from the package APE which do not pass R CMD check for some reason.#
#
########################################################
# SETUP: YOUR TREE FILE AND GEOGRAPHY FILE#
########################################################
# Example files are given below. To run your own data,#
# make the below lines point to your own files, e.g.#
# trfn = "/mydata/frogs/frogBGB/tree.newick"#
# geogfn = "/mydata/frogs/frogBGB/geog.data"#
#
########################################################
# Phylogeny file#
# Notes: #
# 1. Must be binary/bifurcating: no polytomies#
# 2. No negative branchlengths (e.g. BEAST MCC consensus trees sometimes have negative branchlengths)#
# 3. Be careful of very short branches, as BioGeoBEARS will interpret ultrashort branches as direct ancestors#
# 4. You can use non-ultrametric trees, but BioGeoBEARS will interpret any tips significantly below the #
#    top of the tree as fossils!  This is only a good idea if you actually do have fossils in your tree,#
#    as in e.g. Wood, Matzke et al. (2013), Systematic Biology.#
# 5. The default settings of BioGeoBEARS make sense for trees where the branchlengths are in units of #
#    millions of years, and the tree is 1-1000 units tall. If you have a tree with a total height of#
#    e.g. 0.00001, you will need to adjust e.g. the max values of d and e, or (simpler) multiply all#
#    your branchlengths to get them into reasonable units.#
# 6. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
########################################################
# This is the example Newick file for Hawaiian 3taxa#
# (from Ree & Smith 2008)#
# "trfn" = "tree file name"#
trfn = "tree.newick"#
#
# Look at the raw Newick file:#
moref(trfn)#
pdffn = "tree.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
# Look at your phylogeny:#
tr = read.tree(trfn)#
tr#
plot(tr)#
title("Example tree")#
axisPhylo() # plots timescale#
dev.off()#
#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
########################################################
# Geography file#
# Notes:#
# 1. This is a PHYLIP-formatted file. This means that in the #
#    first line, #
#    - the 1st number equals the number of rows (species)#
#    - the 2nd number equals the number of columns (number of areas)#
#    - after a tab, put the areas in parentheses, with spaces: (A B C D)#
##
# 1.5. Example first line:#
#    10    4    (A B C D)#
# #
# 2. The second line, and subsequent lines:#
#    speciesA    0110#
#    speciesB    0111#
#    speciesC    0001#
#         ...#
# #
# 2.5a. This means a TAB between the species name and the area 0/1s#
# 2.5b. This also means NO SPACE AND NO TAB between the area 0/1s.#
# #
# 3. See example files at:#
#    http://phylo.wikidot.com/biogeobears#files#
# #
# 4. Make you understand what a PLAIN-TEXT EDITOR is:#
#    http://phylo.wikidot.com/biogeobears#texteditors#
##
# 3. The PHYLIP format is the same format used for C++ LAGRANGE geography files.#
##
# 4. All names in the geography file must match names in the phylogeny file.#
##
# 5. DON'T USE SPACES IN SPECIES NAMES, USE E.G. "_"#
##
# 6. Operational taxonomic units (OTUs) should ideally be phylogenetic lineages, #
#    i.e. genetically isolated populations.  These may or may not be identical #
#    with species.  You would NOT want to just use specimens, as each specimen #
#    automatically can only live in 1 area, which will typically favor DEC+J #
#    models.  This is fine if the species/lineages really do live in single areas,#
#    but you wouldn't want to assume this without thinking about it at least. #
#    In summary, you should collapse multiple specimens into species/lineages if #
#    data indicates they are the same genetic population.#
#######################################################
#
# This is the example geography file for Hawaiian 3taxa#
# (from Ree & Smith 2008)#
geogfn = "geog.data"#
#
# Look at the raw geography text file:#
moref(geogfn)#
#
# Look at your geographic range data:#
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=geogfn)#
tipranges#
#
# Maximum range size observed:#
max(rowSums(dfnums_to_numeric(tipranges@df)))#
#
# Set the maximum number of areas any species may occupy; this cannot be larger #
# than the number of areas you set up, but it can be smaller.#
max_range_size = 3#
#
#####################################################
#####################################################
# KEY HINT: The number of states (= number of different possible geographic ranges)#
# depends on (a) the number of areas and (b) max_range_size.#
# If you have more than about 500-600 states, the calculations will get REALLY slow,#
# since the program has to exponentiate a matrix of e.g. 600x600.  Often the computer#
# will just sit there and crunch, and never get through the calculation of the first#
# likelihood.#
# #
# (this is also what is usually happening when LAGRANGE hangs: you have too many states!)#
##
# To check the number of states for a given number of ranges, try:#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=4, include_null_range=FALSE)#
numstates_from_numareas(numareas=4, maxareas=3, include_null_range=TRUE)#
numstates_from_numareas(numareas=4, maxareas=2, include_null_range=TRUE)#
#
# Large numbers of areas have problems:#
numstates_from_numareas(numareas=10, maxareas=10, include_null_range=TRUE)#
#
# ...unless you limit the max_range_size:#
numstates_from_numareas(numareas=10, maxareas=2, include_null_range=TRUE)#
#####################################################
#####################################################
#
########################################################
########################################################
# DEC AND DEC+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DEC" model is identical with #
# the Lagrange DEC model, and should return identical#
# ML estimates of parameters, and the same #
# log-likelihoods, for the same datasets.#
##
# Ancestral state probabilities at nodes will be slightly #
# different, since BioGeoBEARS is reporting the #
# ancestral state probabilities under the global ML#
# model, and Lagrange is reporting ancestral state#
# probabilities after re-optimizing the likelihood#
# after fixing the state at each node. These will #
# be similar, but not identical. See Matzke (2014),#
# Systematic Biology, for discussion.#
##
# Also see Matzke (2014) for presentation of the #
# DEC+J model.#
########################################################
########################################################
#
########################################################
########################################################
#
########################################################
# Run DEC#
########################################################
#
# Intitialize a default model (DEC model)#
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
#
# Give BioGeoBEARS the location of the phylogeny Newick file#
BioGeoBEARS_run_object$trfn = trfn#
#
# Give BioGeoBEARS the location of the geography text file#
BioGeoBEARS_run_object$geogfn = geogfn#
#
# Input the maximum range size#
BioGeoBEARS_run_object$max_range_size = max_range_size#
#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
# 1. Here, un-comment ONLY the files you want to use.#
# 2. Also un-comment "BioGeoBEARS_run_object = section_the_tree(...", below.#
# 3. For example files see (a) extdata_dir, #
#  or (b) http://phylo.wikidot.com/biogeobears#files#
#  and BioGeoBEARS Google Group posts for further hints)#
##
# Uncomment files you wish to use in time-stratified analyses:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed_noC.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
# (use more cores to speed it up; this requires#
# library(parallel) and/or library(snow). The package "parallel" #
# is now default on Macs in R 3.0+, but apparently still #
# has to be typed on some Windows machines. Note: apparently #
# parallel works on Mac command-line R, but not R.app.#
# BioGeoBEARS checks for this and resets to 1#
# core with R.app)#
#
# Sparse matrix exponentiation is an option for huge numbers of ranges/states (600+)#
# I have experimented with sparse matrix exponentiation in EXPOKIT/rexpokit,#
# but the results are imprecise and so I haven't explored it further.#
# In a Bayesian analysis, it might work OK, but the ML point estimates are#
# not identical.#
# Also, I have not implemented all functions to work with force_sparse=TRUE.#
# Volunteers are welcome to work on it!!#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC model#
# (nothing to do; defaults)#
#
# Look at the BioGeoBEARS_run_object; it's just a list of settings etc.#
BioGeoBEARS_run_object#
#
# This contains the model object#
BioGeoBEARS_run_object$BioGeoBEARS_model_object#
#
# This table contains the parameters of the model #
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table#
#
# Run this to check inputs. Read the error messages if you get them!#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# For a slow analysis, run once, then set runslow=FALSE to just #
# load the saved result.#
runslow = TRUE#
resfn = "3taxa_DEC_M3areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDEC = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDEC = res#
    }#
#
########################################################
# Run DEC+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed_noC.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DEC+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDEC$outputs@params_table["d","est"]#
estart = resDEC$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Add j as a free parameter#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "3taxa_DEC+J_M3areas_allowed_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDECj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDECj = res#
    }#
#
########################################################
# PDF plots#
########################################################
pdffn = "3taxa_DEC_vs_DEC+J_M3areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DEC#
########################################################
analysis_titletxt ="BioGeoBEARS DEC on 3taxa M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDEC#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DECJ#
########################################################
analysis_titletxt ="BioGeoBEARS DEC+J on 3taxa M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDECj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it#
#
########################################################
########################################################
# DIVALIKE AND DIVALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: The BioGeoBEARS "DIVALIKE" model is not identical with #
# Ronquist (1997)'s parsimony DIVA. It is a likelihood#
# interpretation of DIVA, constructed by modelling DIVA's#
# processes the way DEC does, but only allowing the #
# processes DIVA allows (widespread vicariance: yes; subset#
# sympatry: no; see Ronquist & Sanmartin 2011, Figure 4).#
##
# DIVALIKE is a likelihood interpretation of parsimony#
# DIVA, and it is "like DIVA" -- similar to, but not#
# identical to, parsimony DIVA.#
##
# I thus now call the model "DIVALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run DIVALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed_noC.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE model#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "3taxa_DIVALIKE_M3areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resDIVALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKE = res#
    }#
#
########################################################
# Run DIVALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed_noC.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up DIVALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resDIVALIKE$outputs@params_table["d","est"]#
estart = resDIVALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# Remove subset-sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"#
#
# Allow classic, widespread vicariance; all events equiprobable#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5#
#
# Add jump dispersal/founder-event speciation#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under DIVALIKE+J, the max of "j" should be 2, not 3 (as is default in DEC+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 1.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "3taxa_DIVALIKE+J_M3areas_allowed_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    #sourceall("/Dropbox/_njm/__packages/BioGeoBEARS_setup/")#
#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resDIVALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resDIVALIKEj = res#
    }#
#
pdffn = "3taxa_DIVALIKE_vs_DIVALIKE+J_M3areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - DIVALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE on 3taxa M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDIVALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - DIVALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS DIVALIKE+J on 3taxa M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resDIVALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
########################################################
########################################################
# BAYAREALIKE AND BAYAREALIKE+J ANALYSIS#
########################################################
########################################################
# NOTE: As with DIVA, the BioGeoBEARS BayArea-like model is #
# not identical with the full Bayesian model implemented #
# in the "BayArea" program of Landis et al. (2013). #
##
# Instead, this is a simplified likelihood interpretation#
# of the model.  Basically, in BayArea and BioGeoBEARS-BAYAREALIKE, #
# "d" and "e" work like they do in the DEC model of Lagrange #
# (and BioGeoBEARS), and then BayArea's cladogenesis assumption#
# (which is that nothing in particular happens at cladogenesis) is #
# replicated by BioGeoBEARS.#
##
# This leaves out 3 important things that are in BayArea:#
# 1. Distance dependence (you can add this with a distances #
#    matrix + the "x" parameter in BioGeoBEARS, however)#
# 2. A correction for disallowing "e" events that drive#
#    a species extinct (a null geographic range)#
# 3. The neat Bayesian sampling of histories, which allows#
#    analyses on large numbers of areas.#
##
# The main purpose of having a "BAYAREALIKE" model is #
# to test the importance of the cladogenesis model on #
# particular datasets. Does it help or hurt the data #
# likelihood if there is no special cladogenesis process?#
# #
# BAYAREALIKE is a likelihood interpretation of BayArea,#
# and it is "like BayArea" -- similar to, but not#
# identical to, Bayesian BayArea.#
# I thus now call the model "BAYAREALIKE", and you should also. ;-)#
########################################################
########################################################
#
########################################################
# Run BAYAREALIKE#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed_noC.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE model#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# No jump dispersal/founder-event speciation#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01#
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# Check the inputs#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
runslow = TRUE#
resfn = "3taxa_BAYAREALIKE_M3areas_allowed_v1.Rdata"#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
    resBAYAREALIKE = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKE = res#
    }#
#
########################################################
# Run BAYAREALIKE+J#
########################################################
BioGeoBEARS_run_object = define_BioGeoBEARS_run()#
BioGeoBEARS_run_object$trfn = trfn#
BioGeoBEARS_run_object$geogfn = geogfn#
BioGeoBEARS_run_object$max_range_size = max_range_size#
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)#
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.#
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, #
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of #
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the #
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )#
# Also: search script on "include_null_range" for other places to change#
#
# Set up a time-stratified analysis:#
BioGeoBEARS_run_object$timesfn = "timeperiods.txt"#
#BioGeoBEARS_run_object$dispersal_multipliers_fn = "manual_dispersal_multipliers.txt"#
BioGeoBEARS_run_object$areas_allowed_fn = "areas_allowed_noC.txt"#
#BioGeoBEARS_run_object$areas_adjacency_fn = "areas_adjacency.txt"#
#BioGeoBEARS_run_object$distsfn = "distances_matrix.txt"#
# See notes on the distances model on PhyloWiki's BioGeoBEARS updates page.#
#
# Speed options and multicore processing if desired#
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)#
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)#
BioGeoBEARS_run_object$use_optimx = "GenSA"#
BioGeoBEARS_run_object$num_cores_to_use = 1#
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale#
#
# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!#
# (It also runs some checks on these inputs for certain errors.)#
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
# Divide the tree up by timeperiods/strata (uncomment this for stratified analysis)#
BioGeoBEARS_run_object = section_the_tree(inputs=BioGeoBEARS_run_object, make_master_table=TRUE, plot_pieces=FALSE)#
# The stratified tree is described in this table:#
#BioGeoBEARS_run_object$master_table#
#
# Good default settings to get ancestral states#
BioGeoBEARS_run_object$return_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE#
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run#
#
# Set up BAYAREALIKE+J model#
# Get the ML parameter values from the 2-parameter nested model#
# (this will ensure that the 3-parameter model always does at least as good)#
dstart = resBAYAREALIKE$outputs@params_table["d","est"]#
estart = resBAYAREALIKE$outputs@params_table["e","est"]#
jstart = 0.0001#
#
# Input starting values for d, e#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart#
#
# No subset sympatry#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0#
#
# No vicariance#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0#
#
# *DO* allow jump dispersal/founder-event speciation (set the starting value close to 0)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart#
#
# Under BAYAREALIKE+J, the max of "j" should be 1, not 3 (as is default in DEC+J) or 2 (as in DIVALIKE+J)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
# Adjust linkage between parameters#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"#
#
# Only sympatric/range-copying (y) events allowed, and with #
# exact copying (both descendants always the same size as the ancestor)#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999#
#
# NOTE (NJM, 2014-04): BAYAREALIKE+J seems to crash on some computers, usually Windows #
# machines. I can't replicate this on my Mac machines, but it is almost certainly#
# just some precision under-run issue, when optim/optimx tries some parameter value #
# just below zero.  The "min" and "max" options on each parameter are supposed to#
# prevent this, but apparently optim/optimx sometimes go slightly beyond #
# these limits.  Anyway, if you get a crash, try raising "min" and lowering "max" #
# slightly for each parameter:#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","min"] = 0.0000001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","max"] = 4.9999999#
#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001#
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999#
#
check_BioGeoBEARS_run(BioGeoBEARS_run_object)#
#
resfn = "3taxa_BAYAREALIKE+J_M3areas_allowed_v1.Rdata"#
runslow = TRUE#
if (runslow)#
    {#
    res = bears_optim_run(BioGeoBEARS_run_object)#
    res    #
#
    save(res, file=resfn)#
#
    resBAYAREALIKEj = res#
    } else {#
    # Loads to "res"#
    load(resfn)#
    resBAYAREALIKEj = res#
    }#
#
pdffn = "3taxa_BAYAREALIKE_vs_BAYAREALIKE+J_M3areas_allowed_v1.pdf"#
pdf(pdffn, width=6, height=6)#
#
########################################################
# Plot ancestral states - BAYAREALIKE#
########################################################
analysis_titletxt ="BioGeoBEARS BAYAREALIKE on 3taxa M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resBAYAREALIKE#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
########################################################
# Plot ancestral states - BAYAREALIKE+J#
########################################################
analysis_titletxt ="BioGeoBEARS BAYAREALIKE+J on 3taxa M3areas_allowed_unconstrained"#
#
# Setup#
results_object = resBAYAREALIKEj#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
##########################################################################
##########################################################################
##########################################################################
##########################################################################
# #
# CALCULATE SUMMARY STATISTICS TO COMPARE#
# DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J#
# #
##########################################################################
##########################################################################
##########################################################################
##########################################################################
#
##########################################################################
##########################################################################
# REQUIRED READING:#
##
# Practical advice / notes / basic principles on statistical model #
#    comparison in general, and in BioGeoBEARS:#
# http://phylo.wikidot.com/advice-on-statistical-model-comparison-in-biogeobears#
##########################################################################
##########################################################################
#
# Set up empty tables to hold the statistical results#
restable = NULL#
teststable = NULL#
#
########################################################
# Statistics -- DEC vs. DEC+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDEC)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDECj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# DEC, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDEC, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# DEC+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDECj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
# The null hypothesis for a Likelihood Ratio Test (LRT) is that two models#
# confer the same likelihood on the data. See: Brian O'Meara's webpage:#
# http://www.brianomeara.info/tutorials/aic#
# ...for an intro to LRT, AIC, and AICc#
#
rbind(res2, res1)#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
########################################################
# Statistics -- DIVALIKE vs. DIVALIKE+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKE)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKEj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# DIVALIKE, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# DIVALIKE+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
rbind(res2, res1)#
conditional_format_table(stats)#
#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
########################################################
# Statistics -- BAYAREALIKE vs. BAYAREALIKE+J#
########################################################
# We have to extract the log-likelihood differently, depending on the #
# version of optim/optimx#
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKE)#
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKEj)#
#
numparams1 = 3#
numparams2 = 2#
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)#
stats#
#
# BAYAREALIKE, null model for Likelihood Ratio Test (LRT)#
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
# BAYAREALIKE+J, alternative model for Likelihood Ratio Test (LRT)#
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)#
#
rbind(res2, res1)#
conditional_format_table(stats)#
#
tmp_tests = conditional_format_table(stats)#
#
restable = rbind(restable, res2, res1)#
teststable = rbind(teststable, tmp_tests)#
#
##########################################################################
# ASSEMBLE RESULTS TABLES: DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J#
##########################################################################
teststable$alt = c("DEC+J", "DIVALIKE+J", "BAYAREALIKE+J")#
teststable$null = c("DEC", "DIVALIKE", "BAYAREALIKE")#
row.names(restable) = c("DEC", "DEC+J", "DIVALIKE", "DIVALIKE+J", "BAYAREALIKE", "BAYAREALIKE+J")#
restable = put_jcol_after_ecol(restable)#
restable#
#
# Look at the results!!#
restable#
teststable#
#
########################################################
# Save the results tables for later -- check for e.g.#
# convergence issues#
########################################################
#
# Loads to "restable"#
save(restable, file="restable_v1.Rdata")#
load(file="restable_v1.Rdata")#
#
# Loads to "teststable"#
save(teststable, file="teststable_v1.Rdata")#
load(file="teststable_v1.Rdata")#
#
# Also save to text files#
write.table(restable, file="restable.txt", quote=FALSE, sep="\t")#
write.table(unlist_df(teststable), file="teststable.txt", quote=FALSE, sep="\t")#
#
########################################################
# Model weights of all six models#
########################################################
restable2 = restable#
#
# With AICs:#
AICtable = calc_AIC_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams)#
restable = cbind(restable, AICtable)#
restable_AIC_rellike = AkaikeWeights_on_summary_table(restable=restable, colname_to_use="AIC")#
restable_AIC_rellike = put_jcol_after_ecol(restable_AIC_rellike)#
restable_AIC_rellike#
#
# With AICcs -- factors in sample size#
# samplesize = length(tr$tip.label)#
# AICtable = calc_AICc_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams, samplesize=samplesize)#
# restable2 = cbind(restable2, AICtable)#
# restable_AICc_rellike = AkaikeWeights_on_summary_table(restable=restable2, colname_to_use="AICc")#
# restable_AICc_rellike = put_jcol_after_ecol(restable_AICc_rellike)#
# restable_AICc_rellike#
#
# Also save to text files#
write.table(restable_AIC_rellike, file="restable_AIC_rellike.txt", quote=FALSE, sep="\t")#
#write.table(restable_AICc_rellike, file="restable_AICc_rellike.txt", quote=FALSE, sep="\t")#
#
# Save with nice conditional formatting#
write.table(conditional_format_table(restable_AIC_rellike), file="restable_AIC_rellike_formatted.txt", quote=FALSE, sep="\t")#
#write.table(conditional_format_table(restable_AICc_rellike), file="restable_AICc_rellike_formatted.txt", quote=FALSE, sep="\t")
library(MultinomialCI)#
#
############################################
# Pick your model name:#
############################################
model_name = "BAYAREALIKE"#
res = resBAYAREALIKE#
# model_name = "DEC"#
# res = resDEC#
#
########################################################
# Plot ancestral states - DEC#
########################################################
pdffn = paste0("3taxa_", model_name, "_v1.pdf")#
pdf(pdffn, width=6, height=6)#
#
analysis_titletxt = paste0(model_name, " on 3taxa")#
#
# Setup#
results_object = res#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
#
# States#
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
# Pie chart#
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tr, tipranges=tipranges)#
#
dev.off()  # Turn off PDF#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr) # Plot it#
#
########################################################
# Stochastic mapping on DEC M3b stratified with islands coming up#
########################################################
clado_events_tables = NULL#
ana_events_tables = NULL#
lnum = 0#
#
########################################################
# Get the inputs for Biogeographical Stochastic Mapping#
# Note: this can be slow for large state spaces and trees, since #
# the independent likelihoods for each branch are being pre-calculated#
# E.g., for 10 areas, this requires calculation of a 1024x1024 matrix#
# for each branch.  On a tree with ~800 tips and thus ~1600 branches, this was about 1.6 gigs#
# for storage of "BSM_inputs_file.Rdata".#
# Update: 2015-09-23 -- now, if you used multicore functionality for the ML analysis,#
# the same settings will be used for get_inputs_for_stochastic_mapping().#
########################################################
BSM_inputs_fn = "BSM_inputs_file.Rdata"#
BSMinputs_runslow = TRUE#
if (BSMinputs_runslow == TRUE)#
    {#
    stochastic_mapping_inputs_list = get_inputs_for_stochastic_mapping(res=res)#
    save(stochastic_mapping_inputs_list, file=BSM_inputs_fn)#
    } else {#
    # Loads to "stochastic_mapping_inputs_list"#
    load(BSM_inputs_fn)#
    } # END if (runInputsSlow)#
#
# Check inputs (doesn't work the same on unconstr)#
names(stochastic_mapping_inputs_list)#
stochastic_mapping_inputs_list$phy2#
stochastic_mapping_inputs_list$COO_weights_columnar#
stochastic_mapping_inputs_list$unconstr#
set.seed(seed=as.numeric(Sys.time()))#
#
BSM_runslow = TRUE#
if (BSM_runslow == TRUE)#
    {#
    # Saves to: RES_clado_events_tables.Rdata#
    # Saves to: RES_ana_events_tables.Rdata#
    BSM_output = runBSM(res, stochastic_mapping_inputs_list=stochastic_mapping_inputs_list, maxnum_maps_to_try=100, nummaps_goal=50, maxtries_per_branch=40000, save_after_every_try=TRUE, savedir=getwd(), seedval=12345, wait_before_save=0.01)#
#
    RES_clado_events_tables = BSM_output$RES_clado_events_tables#
    RES_ana_events_tables = BSM_output$RES_ana_events_tables#
    } else {#
    # Load previously saved...#
#
    # Loads to: RES_clado_events_tables#
    load(file="RES_clado_events_tables.Rdata")#
    # Loads to: RES_ana_events_tables#
    load(file="RES_ana_events_tables.Rdata")#
    BSM_output = NULL#
    BSM_output$RES_clado_events_tables = RES_clado_events_tables#
    BSM_output$RES_ana_events_tables = RES_ana_events_tables#
    } # END if (runBSMslow == TRUE)#
#
# Extract BSM output#
clado_events_tables = BSM_output$RES_clado_events_tables#
ana_events_tables = BSM_output$RES_ana_events_tables#
head(clado_events_tables[[1]])#
head(ana_events_tables[[1]])#
length(clado_events_tables)#
length(ana_events_tables)#
#
include_null_range = TRUE#
areanames = names(tipranges@df)#
areas = areanames#
max_range_size = 4#
#
# Note: If you did something to change the states_list from the default given the number of areas, you would#
# have to manually make that change here as well! (e.g., areas_allowed matrix, or manual reduction of the states_list)#
states_list_0based = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)#
#
colors_list_for_states = get_colors_for_states_list_0based(areanames=areanames, states_list_0based=states_list_0based, max_range_size=max_range_size, plot_null_range=TRUE)#
#
# For BSMs, replace white with seashell white#
colors_list_for_states[colors_list_for_states == "#FFFFFF"] = "#FFF5EE"#
#############################################
# Setup for painting a single stochastic map#
#############################################
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
stratified = TRUE#
clado_events_table = clado_events_tables[[1]]#
ana_events_table = ana_events_tables[[1]]#
#
# cols_to_get = names(clado_events_table[,-ncol(clado_events_table)])#
# colnums = match(cols_to_get, names(ana_events_table))#
# ana_events_table_cols_to_add = ana_events_table[,colnums]#
# anagenetic_events_txt_below_node = rep("none", nrow(ana_events_table_cols_to_add))#
# ana_events_table_cols_to_add = cbind(ana_events_table_cols_to_add, anagenetic_events_txt_below_node)#
# rows_to_get_TF = ana_events_table_cols_to_add$node <= length(tr$tip.label)#
# master_table_cladogenetic_events = rbind(ana_events_table_cols_to_add[rows_to_get_TF,], clado_events_table)#
#
#############################################
# Open a PDF#
#############################################
pdffn = paste0(model_name, "_single_stochastic_map_n1.pdf")#
pdf(file=pdffn, width=6, height=6)#
#
# Convert the BSM into a modified res object#
master_table_cladogenetic_events = clado_events_tables[[1]]#
resmod = stochastic_map_states_into_res(res=res, master_table_cladogenetic_events=master_table_cladogenetic_events, stratified=stratified)#
#
plot_BioGeoBEARS_results(results_object=resmod, analysis_titletxt="Stochastic map", addl_params=list("j"), label.offset=0.5, plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, skiptree=FALSE, show.tip.label=TRUE)#
#
# Paint on the branch states#
paint_stochastic_map_branches(res=resmod, master_table_cladogenetic_events=master_table_cladogenetic_events, colors_list_for_states=colors_list_for_states, lwd=5, lty=par("lty"), root.edge=TRUE, stratified=stratified)#
#
plot_BioGeoBEARS_results(results_object=resmod, analysis_titletxt="Stochastic map", addl_params=list("j"), plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, skiptree=TRUE, show.tip.label=TRUE)#
#
#############################################
# Close PDF#
#############################################
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
########################################################
# Plot all 50 stochastic maps to PDF#
########################################################
# Setup#
include_null_range = include_null_range#
areanames = areanames#
areas = areanames#
max_range_size = max_range_size#
states_list_0based = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)#
colors_list_for_states = get_colors_for_states_list_0based(areanames=areanames, states_list_0based=states_list_0based, max_range_size=max_range_size, plot_null_range=TRUE)#
# For BSMs, replace white with seashell white#
colors_list_for_states[colors_list_for_states == "#FFFFFF"] = "#FFF5EE"#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
stratified = stratified#
#
# Loop through the maps and plot to PDF#
pdffn = paste0(model_name, "_", length(clado_events_tables), "BSMs_v1.pdf")#
pdf(file=pdffn, width=6, height=6)#
#
nummaps_goal = 50#
for (i in 1:nummaps_goal)#
    {#
    clado_events_table = clado_events_tables[[i]]#
    analysis_titletxt = paste0(model_name, " - Stochastic Map #", i, "/", nummaps_goal)#
    plot_BSM(results_object=res, clado_events_table=clado_events_table, stratified=stratified, analysis_titletxt=analysis_titletxt, addl_params=list("j"), label.offset=0.5, plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, show.tip.label=TRUE, include_null_range=include_null_range)#
    } # END for (i in 1:nummaps_goal)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)#
#
########################################################
# Summarize stochastic map tables#
########################################################
length(clado_events_tables)#
length(ana_events_tables)#
#
head(clado_events_tables[[1]][,-20])#
tail(clado_events_tables[[1]][,-20])#
#
head(ana_events_tables[[1]])#
tail(ana_events_tables[[1]])#
#
areanames = names(tipranges@df)#
actual_names = areanames#
actual_names#
#
# Get the dmat and times (if any)#
dmat_times = get_dmat_times_from_res(res=res, numstates=NULL)#
dmat_times#
#
# Extract BSM output#
clado_events_tables = BSM_output$RES_clado_events_tables#
ana_events_tables = BSM_output$RES_ana_events_tables#
#
# Simulate the source areas#
BSMs_w_sourceAreas = simulate_source_areas_ana_clado(res, clado_events_tables, ana_events_tables, areanames)#
clado_events_tables = BSMs_w_sourceAreas$clado_events_tables#
ana_events_tables = BSMs_w_sourceAreas$ana_events_tables#
#
# Count all anagenetic and cladogenetic events#
counts_list = count_ana_clado_events(clado_events_tables, ana_events_tables, areanames, actual_names)#
#
summary_counts_BSMs = counts_list$summary_counts_BSMs#
print(conditional_format_table(summary_counts_BSMs))#
#
# Histogram of event counts#
hist_event_counts(counts_list, pdffn=paste0(model_name, "_histograms_of_event_counts.pdf"))#
#
########################################################
# Print counts to files#
########################################################
tmpnames = names(counts_list)#
cat("\n\nWriting tables* of counts to tab-delimited text files:\n(* = Tables have dimension=2 (rows and columns). Cubes (dimension 3) and lists (dimension 1) will not be printed to text files.) \n\n")#
for (i in 1:length(tmpnames))#
    {#
    cmdtxt = paste0("item = counts_list$", tmpnames[i])#
    eval(parse(text=cmdtxt))#
#
    # Skip cubes#
    if (length(dim(item)) != 2)#
        {#
        next()#
        }#
#
    outfn = paste0(tmpnames[i], ".txt")#
    if (length(item) == 0)#
        {#
        cat(outfn, " -- NOT written, *NO* events recorded of this type", sep="")#
        cat("\n")#
        } else {#
        cat(outfn)#
        cat("\n")#
        write.table(conditional_format_table(item), file=outfn, quote=FALSE, sep="\t", col.names=TRUE, row.names=TRUE)#
        } # END if (length(item) == 0)#
    } # END for (i in 1:length(tmpnames))#
cat("...done.\n")#
#
########################################################
# Check that ML ancestral state/range probabilities and#
# the mean of the BSMs approximately line up#
########################################################
library(MultinomialCI)    # For 95% CIs on BSM counts#
check_ML_vs_BSM(res, clado_events_tables, model_name, tr=NULL, plot_each_node=FALSE, linreg_plot=TRUE, MultinomialCI=TRUE)
library(phytools)#
Q = matrix(c(-3,1,1,1,1,-3,1,1,1,1,-3,1,1,1,1,-3),4,4)#
rownames(Q) = letters[1:4]#
colnames(Q) = letters[1:4]#
Q#
#
set.seed(seed=54321)#
simdata = sim.history(tree=tr, Q=Q, nsim=1)#
tipdata = simdata$states#
tipdata#
#
set.seed(seed=54321)#
tr2 = make.simmap(tree=tr, x=tipdata, model="ER")#
tr2#
tr2$mapped.edge#
#
set.seed(seed=54321)#
tr2 = make.simmap(tree=tr, x=sort(tipdata), model="ER")#
tr2#
tr2$mapped.edge
# Plot to PDF#
pdffn = "phytools_simmap.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
plotSimmap(tr2,lwd=3)#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)
lapply(X=tr2$maps, FUN=sum)
res = resBAYAREALIKE#
returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=res$inputs)#
returned_mats#
areanames = returned_mats$areanames#
ranges_list = returned_mats$ranges_list#
#
# Get list of edges:#
trtable = prt(tr, printflag=FALSE)#
trtable
nonroot_TF = trtable$node.type != "root"#
edgenums = trtable$parent_br[nonroot_TF]#
edgenums_order = order(edgenums)#
edgenums = edgenums[edgenums_order]
ancnodenums = trtable$ancestor[nonroot_TF][edgenums_order]#
decnodenums = trtable$node[nonroot_TF][edgenums_order]#
#
# rownames for mapped.edge#
rownames_for_mapped_edge = paste0(ancnodenums, ",", decnodenums)#
rownames_for_mapped_edge#
# Get the specific BSM you want#
clado_events_table = clado_events_tables[[1]]#
ana_events_table = ana_events_tables[[1]]#
clado_events_table#
ana_events_table
maps = list()
i=1
tail(ana_events_table)
edgefound_TF = ana_events_table$parent_br == edgenum
edgenum = edgenums[i]
edgefound_TF = ana_events_table$parent_br == edgenum
edgefound_TF
ana_events_table$parent_br
TF = ana_events_table$event_txt == "A->AB"
TF
ana_events_table[TF,]
clado_events_table
set.seed(seed=as.numeric(54321))#
#
BSM_runslow = TRUE
BSM_output = runBSM(res, stochastic_mapping_inputs_list=stochastic_mapping_inputs_list, maxnum_maps_to_try=100, nummaps_goal=50, maxtries_per_branch=40000, save_after_every_try=TRUE, savedir=getwd(), seedval=12345, wait_before_save=0.01)#
#
    RES_clado_events_tables = BSM_output$RES_clado_events_tables#
    RES_ana_events_tables = BSM_output$RES_ana_events_tables
BSM_output = runBSM(res, stochastic_mapping_inputs_list=stochastic_mapping_inputs_list, maxnum_maps_to_try=1, nummaps_goal=1, maxtries_per_branch=40000, save_after_every_try=TRUE, savedir=getwd(), seedval=12345, wait_before_save=0.01)#
#
    RES_clado_events_tables = BSM_output$RES_clado_events_tables#
    RES_ana_events_tables = BSM_output$RES_ana_events_tables
clado_events_tables = BSM_output$RES_clado_events_tables#
ana_events_tables = BSM_output$RES_ana_events_tables#
head(clado_events_tables[[1]])#
head(ana_events_tables[[1]])#
length(clado_events_tables)#
length(ana_events_tables)
ana_events_tables
tail(ana_events_tables)
clado_events_table = clado_events_tables[[1]]#
ana_events_table = ana_events_tables[[1]]
tail(ana_events_table)
states_list_0based = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)#
#
colors_list_for_states = get_colors_for_states_list_0based(areanames=areanames, states_list_0based=states_list_0based, max_range_size=max_range_size, plot_null_range=TRUE)#
#
# For BSMs, replace white with seashell white#
colors_list_for_states[colors_list_for_states == "#FFFFFF"] = "#FFF5EE"
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
stratified = TRUE#
clado_events_table = clado_events_tables[[1]]#
ana_events_table = ana_events_tables[[1]]#
#
# cols_to_get = names(clado_events_table[,-ncol(clado_events_table)])#
# colnums = match(cols_to_get, names(ana_events_table))#
# ana_events_table_cols_to_add = ana_events_table[,colnums]#
# anagenetic_events_txt_below_node = rep("none", nrow(ana_events_table_cols_to_add))#
# ana_events_table_cols_to_add = cbind(ana_events_table_cols_to_add, anagenetic_events_txt_below_node)#
# rows_to_get_TF = ana_events_table_cols_to_add$node <= length(tr$tip.label)#
# master_table_cladogenetic_events = rbind(ana_events_table_cols_to_add[rows_to_get_TF,], clado_events_table)#
#
#############################################
# Open a PDF#
#############################################
pdffn = paste0(model_name, "_single_stochastic_map_n1.pdf")#
pdf(file=pdffn, width=6, height=6)#
#
# Convert the BSM into a modified res object#
master_table_cladogenetic_events = clado_events_tables[[1]]#
resmod = stochastic_map_states_into_res(res=res, master_table_cladogenetic_events=master_table_cladogenetic_events, stratified=stratified)#
#
plot_BioGeoBEARS_results(results_object=resmod, analysis_titletxt="Stochastic map", addl_params=list("j"), label.offset=0.5, plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, skiptree=FALSE, show.tip.label=TRUE)#
#
# Paint on the branch states#
paint_stochastic_map_branches(res=resmod, master_table_cladogenetic_events=master_table_cladogenetic_events, colors_list_for_states=colors_list_for_states, lwd=5, lty=par("lty"), root.edge=TRUE, stratified=stratified)#
#
plot_BioGeoBEARS_results(results_object=resmod, analysis_titletxt="Stochastic map", addl_params=list("j"), plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, skiptree=TRUE, show.tip.label=TRUE)#
#
#############################################
# Close PDF#
#############################################
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)
tail(ana_events_table)
ana_events_table$parent_br
clado_events_table
names(clado_events_table)
events_txt_list_into_events_table (events_txt_list= clado_events_table$anagenetic_events_txt_below_node)
trtable
events_txt_list_into_events_table (events_txt_list= clado_events_table$anagenetic_events_txt_below_node)
events_txt_list_into_events_table (events_txt_list= clado_events_table$anagenetic_events_txt_below_node, trtable=trtable)
x=events_txt_list_into_events_table (events_txt_list= clado_events_table$anagenetic_events_txt_below_node, trtable=trtable)
tail(x)
x$parent_br
ana_events_table$parent_br
dim(ana_events_table$parent_br)
dim(ana_events_table)
dim(x)
ana_events_table$SUBparent_br
trtable
stochastic_mapping_inputs_list
stochastic_mapping_inputs_list[[1]]
stochastic_mapping_inputs_list[[2]]
stochastic_mapping_inputs_list[[3]]
names(stochastic_mapping_inputs_list)
stochastic_mapping_inputs_list
stochastic_mapping_inputs_list$res$inputs$master_table
stochastic_mapping_inputs_list[[1]]$res$inputs$master_table
stochastic_mapping_inputs_list[[2]]$res$inputs$master_table
stochastic_mapping_inputs_list[[1]]$res$inputs$master_table
stochastic_mapping_inputs_list[[2]]$res$inputs$master_table
stochastic_mapping_inputs_list[[1]]$res$inputs$master_table
names(BSM_output)
BSM_output$RES_clado_events_tables
BSM_output$RES_clado_events_tables$parent_br
BSM_output$RES_clado_events_tables[[1]]$parent_br
BSM_output$RES_clado_events_tables[[1]]
BSM_output$RES_an_events_tables[[1]]
BSM_output$RES_ana_events_tables[[1]]
BSM_output$RES_ana_events_tables[[1]]$parent_br
tail(BSM_output$RES_ana_events_tables[[1]])
x=events_txt_list_into_events_table (events_txt_list= clado_events_table$anagenetic_events_txt_below_node, trtable=trtable)
x
tail(x)
y=events_txt_list_into_events_table (events_txt_list= clado_events_table$anagenetic_events_txt_below_node, trtable= clado_events_table)
y$parent_br
x$parent_br
clado_events_table$parent_br
dim(x)
dim(y)
stochastic_mapping_inputs_list[[1]]$master_table_timeperiod_i
stochastic_mapping_inputs_list[[2]]$master_table_timeperiod_i
master_table_w_stochastic_maps = NULL
for (i in 1:length(stochastic_mapping_inputs_list))#
		{#
		master_table_w_stochastic_maps = rbind(master_table_w_stochastic_maps, stochastic_mapping_inputs_list[[i]]$master_table_timeperiod_i)#
		}#
	#printall(master_table_w_stochastic_maps[,-ncol(master_table_w_stochastic_maps)])#
	dim(master_table_w_stochastic_maps)
y=events_txt_list_into_events_table (events_txt_list= clado_events_table$anagenetic_events_txt_below_node, trtable= master_table_w_stochastic_maps)
y
y$parent_br
tail(y)
y=events_txt_list_into_events_table (events_txt_list= clado_events_table$anagenetic_events_txt_below_node, trtable= master_table_w_stochastic_maps)
clado_events_table$anagenetic_events_txt_below_node
master_table_w_stochastic_maps = NULL
for (i in 1:length(stochastic_mapping_inputs_list))#
		{#
		master_table_w_stochastic_maps = rbind(master_table_w_stochastic_maps, stochastic_mapping_inputs_list[[i]]$master_table_timeperiod_i)#
		}#
	#printall(master_table_w_stochastic_maps[,-ncol(master_table_w_stochastic_maps)])#
	dim(master_table_w_stochastic_maps)
master_table_w_stochastic_maps
events_txt_list = clado_events_table$anagenetic_events_txt_below_node
events_txt_list
trtable = master_table_w_stochastic_maps
if ((length(trtable) > 0) && (class(trtable) == "list"))#
		{#
		txt = "STOP ERROR in events_txt_list_into_events_table(). Input 'trtable' was a list, but should be a data.frame table, or empty. Printing 'trtable':"#
		cat("\n\n")#
		cat(txt)#
		cat("\n\n")#
		print(trtable)#
		cat("\n\n")#
		stop(txt)		#
		}#
	# 2014-05-27_NJM: Note that if you have NO events in the WHOLE TREE, you will#
	# have a "NULL" in events_txt_list.#
	# #
	# Solution: test for NULL. Really, you should pre-allocate this so that #
	# it's never NULL.#
	##
	# Actually, this wasn't the problem since I already did pre-allocation. The problem#
	# was looking for BioGeoBEARS_run_object$states_list when it should have been #
	# looking for res$inputs$states_list#
	if (is.null(events_txt_list))#
		{#
		errortxt = paste("\nWARNING in events_txt_list_into_events_table(): your events_txt_list has NO events!\n\nThis means your tree has NO d/e/a events across the whole tree.\nThis is *expected* e.g. if you inferred d=e=0 under DEC+J. Input a list of '' or NA to avoid this error.\n\n", sep="")#
		cat(errortxt)#
		errortxt2 = paste("events_txt_list_into_events_table() is returning NULL which will might cause issues later.\n\n", sep="")#
		cat(errortxt2)#
		return(NULL)#
		}#
	# Convert NAs to "none"#
	events_txt_list[is.na(events_txt_list)] = "none"#
	# Remove lines with no events or NA:#
	noneTF = events_txt_list == "none"#
	keepTF = (noneTF == FALSE)#
	events_txt_list = events_txt_list[keepTF]
events_txt_list
tmptable = NULL#
	for (i in 1:length(events_txt_list))#
		{#
		#print(events_txt_list)#
		tmptable_rows = events_txt_into_events_table(events_txt_list[i])#
		# NJM 2015-06-08#
		# NJM 2016-05-05 bug fix: add "as.numeric"#
		rownums_in_trtable = as.numeric(tmptable_rows$nodenum_at_top_of_branch)#
		print(rownums_in_trtable)#
		}
trtable
length(events_txt_list)
tmptable_rows
length(trtable)
tmptable_rows
source('/GitHub/BioGeoBEARS/R/BioGeoBEARS_stochastic_mapping_v1.R', chdir = TRUE)
y=events_txt_list_into_events_table (events_txt_list= clado_events_table$anagenetic_events_txt_below_node, trtable= master_table_w_stochastic_maps)
source('/GitHub/BioGeoBEARS/R/BioGeoBEARS_stochastic_mapping_v1.R', chdir = TRUE)
y=events_txt_list_into_events_table (events_txt_list= clado_events_table$anagenetic_events_txt_below_node, trtable= master_table_w_stochastic_maps)
source('/GitHub/BioGeoBEARS/R/BioGeoBEARS_stochastic_mapping_v1.R', chdir = TRUE)
y=events_txt_list_into_events_table (events_txt_list= clado_events_table$anagenetic_events_txt_below_node, trtable= master_table_w_stochastic_maps)
source('/GitHub/BioGeoBEARS/R/BioGeoBEARS_stochastic_mapping_v1.R', chdir = TRUE)
y=events_txt_list_into_events_table (events_txt_list= clado_events_table$anagenetic_events_txt_below_node, trtable= master_table_w_stochastic_maps)
y
y$parent_br
remove.package("BioGeoBEARS")
remove.packages("BioGeoBEARS")
detach("package:BioGeoBEARS")
library(BioGeoBEARS)
library(devtools)
install_github("nmatzke/BioGeoBEARS", dependencies=FALSE)
library(BioGeoBEARS)
remove.packages("BioGeoBEARS")
detach("package:BioGeoBEARS")
library(BioGeoBEARS)
install_local("nmatzke/BioGeoBEARS", dependencies=FALSE)
install_local("/GitHub/BioGeoBEARS", dependencies=FALSE)
BSM_runslow = TRUE#
if (BSM_runslow == TRUE)#
    {#
    # Saves to: RES_clado_events_tables.Rdata#
    # Saves to: RES_ana_events_tables.Rdata#
    BSM_output = runBSM(res, stochastic_mapping_inputs_list=stochastic_mapping_inputs_list, maxnum_maps_to_try=1, nummaps_goal=1, maxtries_per_branch=40000, save_after_every_try=TRUE, savedir=getwd(), seedval=12345, wait_before_save=0.01)#
#
    RES_clado_events_tables = BSM_output$RES_clado_events_tables#
    RES_ana_events_tables = BSM_output$RES_ana_events_tables#
    } else {#
    # Load previously saved...#
#
    # Loads to: RES_clado_events_tables#
    load(file="RES_clado_events_tables.Rdata")#
    # Loads to: RES_ana_events_tables#
    load(file="RES_ana_events_tables.Rdata")#
    BSM_output = NULL#
    BSM_output$RES_clado_events_tables = RES_clado_events_tables#
    BSM_output$RES_ana_events_tables = RES_ana_events_tables#
    } # END if (runBSMslow == TRUE)
library(BioGeoBEARS)
BSM_runslow = TRUE#
if (BSM_runslow == TRUE)#
    {#
    # Saves to: RES_clado_events_tables.Rdata#
    # Saves to: RES_ana_events_tables.Rdata#
    BSM_output = runBSM(res, stochastic_mapping_inputs_list=stochastic_mapping_inputs_list, maxnum_maps_to_try=1, nummaps_goal=1, maxtries_per_branch=40000, save_after_every_try=TRUE, savedir=getwd(), seedval=12345, wait_before_save=0.01)#
#
    RES_clado_events_tables = BSM_output$RES_clado_events_tables#
    RES_ana_events_tables = BSM_output$RES_ana_events_tables#
    } else {#
    # Load previously saved...#
#
    # Loads to: RES_clado_events_tables#
    load(file="RES_clado_events_tables.Rdata")#
    # Loads to: RES_ana_events_tables#
    load(file="RES_ana_events_tables.Rdata")#
    BSM_output = NULL#
    BSM_output$RES_clado_events_tables = RES_clado_events_tables#
    BSM_output$RES_ana_events_tables = RES_ana_events_tables#
    } # END if (runBSMslow == TRUE)
# Extract BSM output#
clado_events_tables = BSM_output$RES_clado_events_tables#
ana_events_tables = BSM_output$RES_ana_events_tables#
head(clado_events_tables[[1]])#
head(ana_events_tables[[1]])#
length(clado_events_tables)#
length(ana_events_tables)#
#
include_null_range = TRUE#
areanames = names(tipranges@df)#
areas = areanames#
max_range_size = 4#
#
# Note: If you did something to change the states_list from the default given the number of areas, you would#
# have to manually make that change here as well! (e.g., areas_allowed matrix, or manual reduction of the states_list)#
states_list_0based = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)#
#
colors_list_for_states = get_colors_for_states_list_0based(areanames=areanames, states_list_0based=states_list_0based, max_range_size=max_range_size, plot_null_range=TRUE)#
#
# For BSMs, replace white with seashell white#
colors_list_for_states[colors_list_for_states == "#FFFFFF"] = "#FFF5EE"#
#############################################
# Setup for painting a single stochastic map#
#############################################
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
stratified = TRUE#
clado_events_table = clado_events_tables[[1]]#
ana_events_table = ana_events_tables[[1]]#
#
# cols_to_get = names(clado_events_table[,-ncol(clado_events_table)])#
# colnums = match(cols_to_get, names(ana_events_table))#
# ana_events_table_cols_to_add = ana_events_table[,colnums]#
# anagenetic_events_txt_below_node = rep("none", nrow(ana_events_table_cols_to_add))#
# ana_events_table_cols_to_add = cbind(ana_events_table_cols_to_add, anagenetic_events_txt_below_node)#
# rows_to_get_TF = ana_events_table_cols_to_add$node <= length(tr$tip.label)#
# master_table_cladogenetic_events = rbind(ana_events_table_cols_to_add[rows_to_get_TF,], clado_events_table)#
#
#############################################
# Open a PDF#
#############################################
pdffn = paste0(model_name, "_single_stochastic_map_n1.pdf")#
pdf(file=pdffn, width=6, height=6)#
#
# Convert the BSM into a modified res object#
master_table_cladogenetic_events = clado_events_tables[[1]]#
resmod = stochastic_map_states_into_res(res=res, master_table_cladogenetic_events=master_table_cladogenetic_events, stratified=stratified)#
#
plot_BioGeoBEARS_results(results_object=resmod, analysis_titletxt="Stochastic map", addl_params=list("j"), label.offset=0.5, plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, skiptree=FALSE, show.tip.label=TRUE)#
#
# Paint on the branch states#
paint_stochastic_map_branches(res=resmod, master_table_cladogenetic_events=master_table_cladogenetic_events, colors_list_for_states=colors_list_for_states, lwd=5, lty=par("lty"), root.edge=TRUE, stratified=stratified)#
#
plot_BioGeoBEARS_results(results_object=resmod, analysis_titletxt="Stochastic map", addl_params=list("j"), plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, skiptree=TRUE, show.tip.label=TRUE)#
#
#############################################
# Close PDF#
#############################################
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)
# Setup#
include_null_range = include_null_range#
areanames = areanames#
areas = areanames#
max_range_size = max_range_size#
states_list_0based = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=include_null_range)#
colors_list_for_states = get_colors_for_states_list_0based(areanames=areanames, states_list_0based=states_list_0based, max_range_size=max_range_size, plot_null_range=TRUE)#
# For BSMs, replace white with seashell white#
colors_list_for_states[colors_list_for_states == "#FFFFFF"] = "#FFF5EE"#
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))#
stratified = stratified#
#
# Loop through the maps and plot to PDF#
pdffn = paste0(model_name, "_", length(clado_events_tables), "BSMs_v1.pdf")#
pdf(file=pdffn, width=6, height=6)#
#
nummaps_goal = 50#
for (i in 1:nummaps_goal)#
    {#
    clado_events_table = clado_events_tables[[i]]#
    analysis_titletxt = paste0(model_name, " - Stochastic Map #", i, "/", nummaps_goal)#
    plot_BSM(results_object=res, clado_events_table=clado_events_table, stratified=stratified, analysis_titletxt=analysis_titletxt, addl_params=list("j"), label.offset=0.5, plotwhat="text", cornercoords_loc=scriptdir, root.edge=TRUE, colors_list_for_states=colors_list_for_states, show.tip.label=TRUE, include_null_range=include_null_range)#
    } # END for (i in 1:nummaps_goal)#
#
dev.off()#
cmdstr = paste("open ", pdffn, sep="")#
system(cmdstr)
length(clado_events_tables)#
length(ana_events_tables)#
#
head(clado_events_tables[[1]][,-20])#
tail(clado_events_tables[[1]][,-20])#
#
head(ana_events_tables[[1]])#
tail(ana_events_tables[[1]])#
#
areanames = names(tipranges@df)#
actual_names = areanames#
actual_names#
#
# Get the dmat and times (if any)#
dmat_times = get_dmat_times_from_res(res=res, numstates=NULL)#
dmat_times#
#
# Extract BSM output#
clado_events_tables = BSM_output$RES_clado_events_tables#
ana_events_tables = BSM_output$RES_ana_events_tables#
#
# Simulate the source areas#
BSMs_w_sourceAreas = simulate_source_areas_ana_clado(res, clado_events_tables, ana_events_tables, areanames)#
clado_events_tables = BSMs_w_sourceAreas$clado_events_tables#
ana_events_tables = BSMs_w_sourceAreas$ana_events_tables#
#
# Count all anagenetic and cladogenetic events#
counts_list = count_ana_clado_events(clado_events_tables, ana_events_tables, areanames, actual_names)#
#
summary_counts_BSMs = counts_list$summary_counts_BSMs#
print(conditional_format_table(summary_counts_BSMs))#
#
# Histogram of event counts#
hist_event_counts(counts_list, pdffn=paste0(model_name, "_histograms_of_event_counts.pdf"))#
#
########################################################
# Print counts to files#
########################################################
tmpnames = names(counts_list)#
cat("\n\nWriting tables* of counts to tab-delimited text files:\n(* = Tables have dimension=2 (rows and columns). Cubes (dimension 3) and lists (dimension 1) will not be printed to text files.) \n\n")#
for (i in 1:length(tmpnames))#
    {#
    cmdtxt = paste0("item = counts_list$", tmpnames[i])#
    eval(parse(text=cmdtxt))#
#
    # Skip cubes#
    if (length(dim(item)) != 2)#
        {#
        next()#
        }#
#
    outfn = paste0(tmpnames[i], ".txt")#
    if (length(item) == 0)#
        {#
        cat(outfn, " -- NOT written, *NO* events recorded of this type", sep="")#
        cat("\n")#
        } else {#
        cat(outfn)#
        cat("\n")#
        write.table(conditional_format_table(item), file=outfn, quote=FALSE, sep="\t", col.names=TRUE, row.names=TRUE)#
        } # END if (length(item) == 0)#
    } # END for (i in 1:length(tmpnames))#
cat("...done.\n")#
#
########################################################
# Check that ML ancestral state/range probabilities and#
# the mean of the BSMs approximately line up#
########################################################
library(MultinomialCI)    # For 95% CIs on BSM counts#
check_ML_vs_BSM(res, clado_events_tables, model_name, tr=NULL, plot_each_node=FALSE, linreg_plot=TRUE, MultinomialCI=TRUE)
library(phytools)#
Q = matrix(c(-3,1,1,1,1,-3,1,1,1,1,-3,1,1,1,1,-3),4,4)#
rownames(Q) = letters[1:4]#
colnames(Q) = letters[1:4]#
Q#
#
set.seed(seed=54321)#
simdata = sim.history(tree=tr, Q=Q, nsim=1)#
tipdata = simdata$states#
tipdata#
#
set.seed(seed=54321)#
tr2 = make.simmap(tree=tr, x=tipdata, model="ER")#
tr2#
tr2$mapped.edge#
#
set.seed(seed=54321)#
tr2 = make.simmap(tree=tr, x=sort(tipdata), model="ER")#
tr2#
tr2$mapped.edge#
#
# Same!#
# Plot to PDF#
pdffn = "phytools_simmap.pdf"#
pdf(file=pdffn, width=6, height=6)#
#
plotSimmap(tr2,lwd=3)#
#
dev.off()#
cmdstr = paste0("open ", pdffn)#
system(cmdstr)#
# The key things to add to make a simmap object:#
# 1. Tree#
# 2. "maps" -- a list of branches. For each branch, a vector of times spent in each state, from branch beginning to end#
#
# I.e., the branches sum to edge lengths:#
lapply(X=tr2$maps, FUN=sum)#
# [[1]]#
# [1] 1#
# #
# [[2]]#
# [1] 1#
# #
# [[3]]#
# [1] 1#
# #
# [[4]]#
# [1] 2#
# 3. "mapped.edge" -- sum of time spent in each state#
# 4. "Q" -- the transition matrix#
# 5. "logL" -- "the log-likelihood of the assumed or sampled Q." -- actually, #
#     he means the probability of the tip data (the log-likelihood), given the Q model & tree #
# Produce "maps" from the ana_events_table#
res = resBAYAREALIKE#
returned_mats = get_Qmat_COOmat_from_BioGeoBEARS_run_object(BioGeoBEARS_run_object=res$inputs)#
returned_mats#
areanames = returned_mats$areanames#
ranges_list = returned_mats$ranges_list#
#
# Get list of edges:#
trtable = prt(tr, printflag=FALSE)#
trtable#
#
#trtable = res$inputs$master_table#
#trtable#
#
# Get the edgenums, exclude the "NA" for the root branch#
# Order edgenums from smallest to largest#
nonroot_TF = trtable$node.type != "root"#
edgenums = trtable$parent_br[nonroot_TF]#
edgenums_order = order(edgenums)#
edgenums = edgenums[edgenums_order]#
#
# Get the "ancestor node, descendant node"#
ancnodenums = trtable$ancestor[nonroot_TF][edgenums_order]#
decnodenums = trtable$node[nonroot_TF][edgenums_order]#
#
# rownames for mapped.edge#
rownames_for_mapped_edge = paste0(ancnodenums, ",", decnodenums)#
rownames_for_mapped_edge#
# Get the specific BSM you want#
clado_events_table = clado_events_tables[[1]]#
ana_events_table = ana_events_tables[[1]]#
clado_events_table#
ana_events_table#
#
# instantiate "maps" for phytools (a list, with array of state residence times#
maps = list()
edgenums
edgenum = edgenums[i]#
	# Trap for if ana_events_table is NA (common, if there are no anagenetic events in#
	# the tree at all)#
	if ( (length(ana_events_table) == 1) && (is.na(ana_events_table)) )#
		{#
		edgefound_TF = FALSE#
		} else {#
		edgefound_TF = ana_events_table$parent_br == edgenum#
		}
edgefound_TF
tail(ana_events_table)
ana_events_table
ana_events_table$parent_br
remove.packages("BioGeoBEARS")
detach(package:BioGeoBEARS)
